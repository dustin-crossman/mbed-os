/***************************************************************************//**
* \file cy_capsense_control.c
* \version 1.1
*
* \brief
* This file provides the source code to the Control module functions.
*
********************************************************************************
* \copyright
* Copyright 2018-2019 Cypress Semiconductor Corporation
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*******************************************************************************/

#include <stddef.h>
#include "cy_syslib.h"
#include "cy_syspm.h"
#include "cy_csd.h"
#include "cy_capsense_common.h"
#include "cy_capsense_structure.h"
#include "cy_capsense_control.h"
#include "cy_capsense_processing.h"
#include "cy_capsense_filter.h"
#include "cy_capsense_sensing.h"
#include "cy_capsense_tuner.h"


/*******************************************************************************
* Function Name: Cy_CapSense_Init
****************************************************************************//**
*
* Captures the CSD HW block and configures it to default state. This function is
* called by the application program prior to calling any other function of the
* middleware.
*
* The following tasks are executed:
* 1. Capturing CSD HW block. If hardware is already in use, then the function
*    returns fail status and corresponding actions like releasing the CSD block
*    should be performed on the application level.
* 2. If HW block was captured the function configures it to the default state.
*
* The most common CapSense initialization process includes:
* 1. Calling this function Cy_CapSense_Init().
* 2. Initializing CSD HW block interrupts by enabling it and assigning
*    corresponding interrupt handler in main.c file.
* 3. Calling Cy_CapSense_Enable() function.
*
* When the middleware operation is stopped by the Cy_CapSense_DeInit()
* function, the Cy_CapSense_Init() function repeats an initialization
* process.
*
* \param context
* The pointer to the CapSense context structure \ref cy_stc_capsense_context_t
* generated by CapSense configuration tool. The structure contains both, CapSense
* configuration and internal data and it is used during whole CapSense operation.
*
* \return
* Returns the status of the initialization process. If CY_RET_SUCCESS is not
* received, some of the initialization fails, the middleware may not operate
* as expected, and repeating of initialization is required.
*
* \funcusage
* \snippet capsense\1.0\snippet\main.c snippet_Cy_CapSense_Initialization
* The 'cy_capsense_context' variable that is used as the parameter of the
* Cy_CapSense_Init() and Cy_CapSense_Enable() functions is declared in the
* cycfg_capsense.h file.
* The CapSense_ISR_cfg variable should be declared on the application
* layer according to the examples below:<br>
* For M0p core:<br>
* \snippet capsense\1.0\snippet\main.c snippet_m0p_capsense_interrupt_source_declaration
*
* For M4 core:
* \snippet capsense\1.0\snippet\main.c snippet_m4_capsense_interrupt_source_declaration
*
* The CapSense interrupt handler should be declared on the application layer
* according to example below:
* \snippet capsense\1.0\snippet\main.c snippet_Cy_CapSense_IntHandler
*
* The CapSense_HW defines the base address of the CSD HW block used. The definition is
* is placed in the cycfg_peripherals.h file.
*
*******************************************************************************/
cy_status Cy_CapSense_Init(cy_stc_capsense_context_t * context)
{
    cy_status result = CY_RET_BAD_PARAM;

    if (NULL != context)
    {
        result = Cy_CapSense_Restore(context);

        /* The 25us interval is required for settling analog part of the CSD HW block. */
        Cy_SysLib_DelayUs(CY_CAPSENSE_ANALOG_SETTLING_TIME_US);
    }

    return result;
}


/*******************************************************************************
* Function Name: Cy_CapSense_Enable
****************************************************************************//**
*
* Initializes the CapSense firmware modules. This function is called by the
* application program after Cy_CapSense_Init() function. The function requires
* CSD HW block interrupt to be correctly configured.
*
* The following are executed as part of the function:
* 1. Check CapSense configuration integrity.
* 2. Pre-calculate of internal register values to speed up operation.
* 3. Configure the hardware to perform capacitive sensing.
* 4. If SmartSense Auto-tuning is selected for the CSD Tuning mode in the
*    Basic tab, the auto-tuning algorithm is executed to set the optimal
*    values for the hardware parameters of the widgets/sensors.
* 5. Calibrate the sensors and find the optimal values for IDACs of each
*    widget/sensor, if the Enable IDAC auto-calibration is enabled in the
*    CSD Setting or CSX Setting tabs.
* 5. Perform scanning for all the sensors and initialize the baseline history.
* 6. If the firmware filters are enabled in the Advanced General tab, the
*    filter histories are also initialized.
*
* Any next call of this function repeats an initialization process except for
* data structure initialization. Therefore, it is possible to change the
* middleware configuration from the application program by writing registers
* to the data structure and calling this function again. This is also
* done inside the Cy_CapSense_RunTuner() function when a restart command
* is received.
*
* \param context
* The pointer to the CapSense context structure \ref cy_stc_capsense_context_t.
*
* \return
* Returns the status of the initialization process. If CY_RET_SUCCESS is not
* received, some of the initialization fails.
*
* \funcusage
* \snippet capsense\1.0\snippet\main.c snippet_Cy_CapSense_Initialization
* The 'cy_capsense_context' variable that is used as the parameter of the
* Cy_CapSense_Init() and Cy_CapSense_Enable() functions is declared in the
* cycfg_capsense.h file.
* The CapSense_ISR_cfg variable should be declared on the application
* layer according to the examples below:<br>
* For M0p core:<br>
* \snippet capsense\1.0\snippet\main.c snippet_m0p_capsense_interrupt_source_declaration
*
* For M4 core:
* \snippet capsense\1.0\snippet\main.c snippet_m4_capsense_interrupt_source_declaration
*
* The CapSense interrupt handler should be declared on the application layer
* according to example below:
* \snippet capsense\1.0\snippet\main.c snippet_Cy_CapSense_IntHandler
*
* The CapSense_HW defines the base address of the CSD HW block used. The definition is
* is placed in the cycfg_peripherals.h file.
*
*******************************************************************************/
cy_status Cy_CapSense_Enable(cy_stc_capsense_context_t * context)
{
    cy_status result;
    uint32_t cpuFreqMHz;
    uint32_t watchdogCounter;

    /* Approximate duration of Wait For Init loop */
    const uint32_t isBusyLoopDuration = 5uL;

    /* Wait For Init watchdog timeout in microseconds */
    const uint32_t isBusyWatchdogTimeUs = 1000000uL;

    /* Initialize CapSense modules */
    result = Cy_CapSense_Initialize(context);

    if(CY_RET_SUCCESS == result)
    {
        if (CY_CAPSENSE_CSD_SS_DIS != context->ptrCommonConfig->csdAutotuneEn)
        {
            result |= Cy_CapSense_SsAutoTune(context);
        }

        if ((CY_CAPSENSE_ENABLE == context->ptrCommonConfig->csdEn) &&
           (CY_CAPSENSE_CSD_SS_DIS == context->ptrCommonConfig->csdAutotuneEn) &&
           (CY_CAPSENSE_ENABLE == context->ptrCommonConfig->csdIdacAutocalEn))
        {
            result |= Cy_CapSense_CalibrateAllCsdWidgets(context);
        }

        if((CY_CAPSENSE_ENABLE == context->ptrCommonConfig->csxEn) &&
           (CY_CAPSENSE_ENABLE == context->ptrCommonConfig->csxIdacAutocalEn))
        {
            result |= Cy_CapSense_CalibrateAllCsxWidgets(context);
        }


        result |= Cy_CapSense_ScanAllWidgets(context);
        /* Init Watchdog Counter to prevent a hang */
        cpuFreqMHz = context->ptrCommonConfig->cpuClkHz / 1000000uL;
        watchdogCounter = Cy_CapSense_WatchdogCyclesNum(isBusyWatchdogTimeUs, cpuFreqMHz, isBusyLoopDuration);

        while(CY_CAPSENSE_NOT_BUSY != Cy_CapSense_IsBusy(context))
        {
            if(0uL == watchdogCounter)
            {
                break;
            }

            watchdogCounter--;
        }
    }

    Cy_CapSense_InitializeAllFilters(context);
    Cy_CapSense_InitializeAllBaselines(context);

    return result;
}


/*******************************************************************************
* Function Name: Cy_CapSense_Initialize
****************************************************************************//**
*
* Initializes all sub-modules of the CapSense middleware.
*
* The initialization includes:
* - Data Structure - set the default middleware parameters based
*   on configuration.
* - Data Processing - resets the status all widgets.
* - Tuner - resets the tuner communication state.
* - Sensing - prepares CSD HW for operation.
*
* \param context
* The pointer to the CapSense context structure \ref cy_stc_capsense_context_t.
*
* \return
* Return CY_RET_SUCCESS if the initialization was successful.
*
*******************************************************************************/
cy_status Cy_CapSense_Initialize(cy_stc_capsense_context_t * context)
{
    cy_status result = CY_RET_INVALID_STATE;

    result = Cy_CapSense_CheckConfigIntegrity(context);
    if (CY_RET_SUCCESS == result)
    {
        /* The Tuner is initialized only once */
        if (CY_CAPSENSE_INIT_NEEDED == context->ptrCommonContext->initDone)
        {
            Cy_CapSense_TuInitialize(context);
            context->ptrCommonContext->initDone = CY_CAPSENSE_INIT_DONE;
        }

        Cy_CapSense_InitializeAllStatuses(context);
        result = Cy_CapSense_SsInitialize(context);
    }
    
    return (result);
}


/*******************************************************************************
* Function Name: Cy_CapSense_DeInit
****************************************************************************//**
*
* Stops the middleware operation.
*
* This function stops the middleware operation. No sensor scanning can be
* executed when the middleware is stopped. After it is stopped, the hardware block may
* be reconfigured by the application program for any other special usage. The
* middleware operation can be resumed by calling the Cy_CapSense_Init()
* function.
*
* This function is called when no scanning is in progress.
* I.e. Cy_CapSense_IsBusy() returns a non-busy status.
*
* \param context
* The pointer to the CapSense context structure \ref cy_stc_capsense_context_t.
*
* \return
* Returns the status of the stop process. If CY_RET_SUCCESS is not received,
* the stop process fails and retries may be required.
*
*******************************************************************************/
cy_status Cy_CapSense_DeInit(cy_stc_capsense_context_t * context)
{
    cy_status result = CY_RET_SUCCESS;

    if (CY_CSD_SUCCESS != Cy_CapSense_Save(context))
    {
        result = CY_RET_BAD_DATA;
    }
    else
    {
        context->ptrCommonContext->initDone = CY_CAPSENSE_INIT_NEEDED;
    }

    return (result);
}


/*******************************************************************************
* Function Name: Cy_CapSense_ProcessAllWidgets
****************************************************************************//**
*
* Performs full data processing of all enabled widgets.
*
* This function performs all data processes for all enabled widgets in the
* middleware. The following tasks are executed as part of processing all the
* widgets:
* 1. Apply raw count filters to the raw counts, if they are enabled.
* 2. Update the thresholds if the SmartSense Full Auto-Tuning is enabled.
* 3. Update the baselines and difference counts for all the sensors.
* 4. Update the sensor and widget status (on/off), update the centroid for
*    the sliders and the X/Y position for the touchpads.
*
* This function is called by an application program only after all the enabled
* widgets (and sensors) in the middleware are scanned. Calling this function
* multiple times without sensor scanning causes unexpected behavior.
*
* The disabled widgets are not processed by this function.
*
* \param context
* The pointer to the CapSense context structure \ref cy_stc_capsense_context_t.
*
* \return
* Returns the status of the processing operation. If CY_RET_SUCCESS is not received,
* the processing fails and retries may be required.
*
*******************************************************************************/
cy_status Cy_CapSense_ProcessAllWidgets(cy_stc_capsense_context_t * context)
{
    uint32_t wdIndex;
    cy_status result = CY_RET_SUCCESS;

    for (wdIndex = context->ptrCommonConfig->numWd; wdIndex-- > 0u;)
    {
        result |= Cy_CapSense_ProcessWidget(wdIndex, context);
    }
    return result;
}


/*******************************************************************************
* Function Name: Cy_CapSense_ProcessWidget
****************************************************************************//**
*
* Performs full data processing of the specified widget if it is enabled.
*
* This function performs exactly the same tasks as
* Cy_CapSense_ProcessAllWidgets(), but only for a specified widget. This
* function can be used along with the Cy_CapSense_SetupWidget() and
* Cy_CapSense_Scan() functions to scan and process data for a specific
* widget. This function is called only after all the sensors in the
* widgets are scanned. A disabled widget is not processed by this function.
*
* A pipeline scan method (i.e. during scanning of a widget performing processing
* of the previously scanned widget) can be implemented using this function and
* it may reduce the total execution time, increase the refresh rate and
* decrease the average power consumption.
*
* \param widgetId
* Specifies the ID number of a widget.
*
* \param context
* The pointer to the CapSense context structure \ref cy_stc_capsense_context_t.
*
* \return
* Returns the status of the widget processing:
* - CY_RET_SUCCESS       - The operation is successfully completed
* - CY_RET_BAD_PARAM     - The input parameter is invalid
* - CY_RET_INVALID_STATE - The specified widget is disabled
* - CY_RET_BAD_DATA      - The processing is failed
*
*******************************************************************************/
cy_status Cy_CapSense_ProcessWidget(uint32_t widgetId, cy_stc_capsense_context_t * context)
{
    cy_status result = CY_RET_BAD_PARAM;
    const cy_stc_capsense_widget_config_t * ptrWdCfg;

    /* Check parameter validity */
    if (widgetId < context->ptrCommonConfig->numWd)
    {
        ptrWdCfg = &context->ptrWdConfig[widgetId];
        
        /* Check widget enable status */
        if (0u == (ptrWdCfg->ptrWdContext->status & CY_CAPSENSE_WD_DISABLE_MASK))
        {
            switch(ptrWdCfg->senseMethod)
            {
                case (uint8_t)CY_CAPSENSE_SENSE_METHOD_CSD_E:
                    result = Cy_CapSense_DpProcessCsdWidgetRawCounts(ptrWdCfg, context);
                    Cy_CapSense_DpProcessCsdWidgetStatus(ptrWdCfg, context);
                    break;

                case (uint8_t)CY_CAPSENSE_SENSE_METHOD_CSX_E:
                    result = Cy_CapSense_DpProcessCsxWidgetRawCounts(ptrWdCfg, context);
                    Cy_CapSense_DpProcessCsxWidgetStatus(ptrWdCfg, context);
                    break;

            default:
                CY_ASSERT(0 != 0);
                break;
            }
        }
        else
        {
            result = CY_RET_INVALID_STATE;
        }
    }
    return result;
}


/*******************************************************************************
* Function Name: Cy_CapSense_ProcessWidgetExt
****************************************************************************//**
*
* Performs customized data processing on the selected widget.
*
* This function performs data processes for the specified widget specified by
* the mode parameter. The execution order of the requested operations is from
* LSB to MSB of the mode parameter. For a different order, this function
* can be called multiple times with the required mode parameter.
*
* This function can be used with any of the available scan functions. This
* function is called only after all the sensors in the specified widget are
* scanned. Calling this function multiple times with the same mode without
* sensor scanning causes unexpected behavior. This function ignores the value
* of the wdgtEnable register.
*
* The CY_CAPSENSE_PROCESS_CALC_NOISE and CY_CAPSENSE_PROCESS_THRESHOLDS 
* flags are supported by the CSD sensing method only when SmartSense is enabled.
*
* The pipeline scan method (i.e. during scanning of a widget, processing
* of a previously scanned widget is performed) can be implemented using this
* function and it may reduce the total scan/process time, increase the refresh
* rate, and decrease the power consumption.
*
* \param widgetId
* Specifies the ID number of a widget.
*
* \param mode
* Specifies the type of widget processing to be executed for the
* specified widget:
* 1. Bits [31..6] - Reserved.
* 2. Bits [5..0]  - CY_CAPSENSE_PROCESS_ALL - Execute all the tasks.
* 3. Bit [5]      - CY_CAPSENSE_PROCESS_STATUS - Update the status 
*                   (on/off, centroid position).
* 4. Bit [4]      - CY_CAPSENSE_PROCESS_THRESHOLDS - Update the thresholds
*                   (only in CSD auto-tuning mode).
* 5. Bit [3]      - CY_CAPSENSE_PROCESS_CALC_NOISE - Calculate the noise 
*                   (only in CSD auto-tuning mode).
* 6. Bit [2]      - CY_CAPSENSE_PROCESS_DIFFCOUNTS - Update the difference counts.
* 7. Bit [1]      - CY_CAPSENSE_PROCESS_BASELINE - Update the baselines.
* 8. Bit [0]      - CY_CAPSENSE_PROCESS_FILTER - Run the firmware filters.
*
* \param context
* The pointer to the CapSense context structure \ref cy_stc_capsense_context_t.
*
* \return
* Returns the status of the widget processing operation:
* - CY_RET_SUCCESS      - The processing is successfully performed.
* - CY_RET_BAD_PARAM    - The input parameter is invalid.
* - CY_RET_BAD_DATA     - The processing failed.
*
*******************************************************************************/
cy_status Cy_CapSense_ProcessWidgetExt(
                uint32_t widgetId, 
                uint32_t mode, 
                cy_stc_capsense_context_t * context)
{
    uint32_t snsIndex;
    cy_status result = CY_RET_BAD_PARAM;
    uint32_t snsHistorySize;
    uint32_t freqChIndex;
    uint32_t freqChNumber;
    uint16_t * ptrHistoryCh;
    uint16_t * ptrHistorySns;
    uint8_t * ptrHistoryLowCh = NULL;
    uint8_t * ptrHistoryLowSns = NULL;
    cy_stc_capsense_sensor_context_t * ptrSnsCxtCh;
    cy_stc_capsense_sensor_context_t * ptrSnsCxtSns;
    const cy_stc_capsense_widget_config_t * ptrWdCfg;
    
    
    /* Check parameter validity */
    if (widgetId < context->ptrCommonConfig->numWd)
    {
        ptrWdCfg = &context->ptrWdConfig[widgetId];
        snsHistorySize = (uint32_t)ptrWdCfg->rawFilterConfig & CY_CAPSENSE_RC_FILTER_SNS_HISTORY_SIZE_MASK;
        freqChNumber = (CY_CAPSENSE_ENABLE == context->ptrCommonConfig->mfsEn) ? 3u : 1u;

        ptrSnsCxtCh = &ptrWdCfg->ptrSnsContext[0u];
        ptrHistoryCh = &ptrWdCfg->ptrRawFilterHistory[0u];
        if(CY_CAPSENSE_IIR_FILTER_PERFORMANCE == (ptrWdCfg->rawFilterConfig & CY_CAPSENSE_RC_FILTER_IIR_MODE_MASK))
        {
            ptrHistoryLowCh = &ptrWdCfg->ptrRawFilterHistoryLow[0u];
        }


        switch(ptrWdCfg->senseMethod)
        {
            case (uint8_t)CY_CAPSENSE_SENSE_METHOD_CSD_E:
                
                /* Run the desired processing for the all CSD widget sensors */
                for(freqChIndex = 0u; freqChIndex < freqChNumber; freqChIndex++)
                {
                    ptrSnsCxtSns = ptrSnsCxtCh;
                    ptrHistorySns = ptrHistoryCh;
                    ptrHistoryLowSns = ptrHistoryLowCh;
                    for (snsIndex = 0uL; snsIndex < ptrWdCfg->numSns; snsIndex++)
                    {                    
                        result = Cy_CapSense_DpProcessCsdSensorRawCountsExt(ptrWdCfg, ptrSnsCxtSns, ptrHistorySns, ptrHistoryLowSns, mode, context);

                        ptrSnsCxtSns++;
                        ptrHistorySns += snsHistorySize;
                        if(NULL != ptrHistoryLowSns)
                        {
                            ptrHistoryLowSns++;
                        }

                    }

                    ptrSnsCxtCh += context->ptrCommonConfig->numSns;
                    ptrHistoryCh += context->ptrCommonConfig->numSns * snsHistorySize;
                    if(NULL != ptrHistoryLowCh)
                    {
                        ptrHistoryLowCh += context->ptrCommonConfig->numSns;
                    }

                }

                if(CY_CAPSENSE_ENABLE == context->ptrCommonConfig->mfsEn)
                {
                    ptrSnsCxtSns = ptrWdCfg->ptrSnsContext;
                    for (snsIndex = ptrWdCfg->numSns; snsIndex-- > 0u;)
                    {
                        Cy_CapSense_RunMfsFiltering(ptrSnsCxtSns, context);
                        ptrSnsCxtSns++;
                    }
                }

                if (0u != (mode & CY_CAPSENSE_PROCESS_STATUS))
                {
                    Cy_CapSense_DpProcessCsdWidgetStatus(ptrWdCfg, context);
                }
                break;

            case (uint8_t)CY_CAPSENSE_SENSE_METHOD_CSX_E:

                /* Run the desired processing for the all CSX widget sensors */
                for(freqChIndex = 0u; freqChIndex < freqChNumber; freqChIndex++)
                {
                    ptrSnsCxtSns = ptrSnsCxtCh;
                    ptrHistorySns = ptrHistoryCh;
                    ptrHistoryLowSns = ptrHistoryLowCh;
                    for (snsIndex = 0uL; snsIndex < ptrWdCfg->numSns; snsIndex++)
                    {
                        result = Cy_CapSense_DpProcessCsxSensorRawCountsExt(ptrWdCfg, ptrSnsCxtSns, ptrHistorySns, ptrHistoryLowSns, mode, context);

                        ptrSnsCxtSns++;
                        ptrHistorySns += snsHistorySize;
                        if(NULL != ptrHistoryLowSns)
                        {
                            ptrHistoryLowSns++;
                        }

                    }

                    ptrSnsCxtCh += context->ptrCommonConfig->numSns;
                    ptrHistoryCh += context->ptrCommonConfig->numSns * snsHistorySize;
                    if(NULL != ptrHistoryLowCh)
                    {
                        ptrHistoryLowCh += context->ptrCommonConfig->numSns;
                    }

                }

                if(CY_CAPSENSE_ENABLE == context->ptrCommonConfig->mfsEn)
                {
                    ptrSnsCxtSns = ptrWdCfg->ptrSnsContext;
                    for (snsIndex = ptrWdCfg->numSns; snsIndex-- > 0u;)
                    {
                        Cy_CapSense_RunMfsFiltering(ptrSnsCxtSns, context);
                        ptrSnsCxtSns++;
                    }
                }

                if (0u != (mode & CY_CAPSENSE_PROCESS_STATUS))
                {
                    Cy_CapSense_DpProcessCsxWidgetStatus(ptrWdCfg, context);
                }
                break;

        default:
            CY_ASSERT(0 != 0);
            break;
        }
    }
    return result;
}

/*******************************************************************************
* Function Name: Cy_CapSense_ProcessSensorExt
****************************************************************************//**
*
* Performs customized data processing on the selected widget's sensor.
*
* This function performs data processes for the specified sensor specified by
* the mode parameter. The execution order of the requested operations is from
* LSB to MSB of the mode parameter. For a different order, this
* function can be called multiple times with the required mode parameter.
*
* This function can be used with any of the available scan functions. This
* function is called only after a specified sensor in the widget is
* scanned. Calling this function multiple times with the same mode without
* sensor scanning causes unexpected behavior. This function ignores the value
* of the wdgtEnable register.
*
* The CY_CAPSENSE_PROCESS_CALC_NOISE and CY_CAPSENSE_PROCESS_THRESHOLDS 
* flags are supported by the CSD sensing method only when SmartSense is enabled.
*
* The pipeline scan method (i.e. during scanning of a sensor, processing
* of a previously scanned sensor is performed) can be implemented using this
* function and it may reduce the total scan/process time, increase the refresh
* rate, and decrease the power consumption.
*
* \param widgetId
* Specifies the ID number of a widget.
*
* \param sensorId
* Specifies the ID number of the sensor within the widget to process it.
*
* \param mode
* Specifies the type of the sensor processing that needs to be executed for the
* specified sensor:
* 1. Bits [31..5] - Reserved
* 2. Bits [4..0]  - CY_CAPSENSE_PROCESS_ALL - Executes all the tasks
* 3. Bit [4]      - CY_CAPSENSE_PROCESS_THRESHOLDS - Updates the thresholds 
*                   (only in auto-tuning mode)
* 4. Bit [3]      - CY_CAPSENSE_PROCESS_CALC_NOISE - Calculates the noise 
*                   (only in auto-tuning mode)
* 5. Bit [2]      - CY_CAPSENSE_PROCESS_DIFFCOUNTS - Updates the diffcount
* 6. Bit [1]      - CY_CAPSENSE_PROCESS_BASELINE - Updates the baseline
* 7. Bit [0]      - CY_CAPSENSE_PROCESS_FILTER - Runs the firmware filters
*
* \param context
* The pointer to the CapSense context structure \ref cy_stc_capsense_context_t.
*
* \return
* Returns the status of the sensor process operation:
* - CY_RET_SUCCESS      - The processing is successfully performed.
* - CY_RET_BAD_PARAM    - The input parameter is invalid.
* - CY_RET_BAD_DATA     - The processing failed.
*
*******************************************************************************/
cy_status Cy_CapSense_ProcessSensorExt(
                uint32_t widgetId, 
                uint32_t sensorId, 
                uint32_t mode, 
                const cy_stc_capsense_context_t * context)
{
    cy_status result = CY_RET_BAD_PARAM;

    uint32_t freqChIndex;
    uint32_t freqChNumber;
    uint32_t snsHistorySize;
    uint32_t cxtOffset;
    uint32_t historyOffset;

    uint16_t * ptrHistory;
    uint8_t  * ptrHistoryLow = NULL;
    const cy_stc_capsense_widget_config_t * ptrWdCfg;
    cy_stc_capsense_sensor_context_t * ptrSnsCxt;

    if (widgetId < context->ptrCommonConfig->numWd)
    {
        ptrWdCfg = &context->ptrWdConfig[widgetId];
        if (sensorId < ptrWdCfg->numSns)
        {
            snsHistorySize = (uint32_t)ptrWdCfg->rawFilterConfig & CY_CAPSENSE_RC_FILTER_SNS_HISTORY_SIZE_MASK;
            freqChNumber = (CY_CAPSENSE_ENABLE == context->ptrCommonConfig->mfsEn) ? 3u : 1u;
            ptrHistory = &ptrWdCfg->ptrRawFilterHistory[sensorId * snsHistorySize];
            if((uint32_t)CY_CAPSENSE_IIR_FILTER_PERFORMANCE == ((uint32_t)ptrWdCfg->rawFilterConfig & (uint32_t)CY_CAPSENSE_RC_FILTER_IIR_MODE_MASK))
            {
                ptrHistoryLow =  &ptrWdCfg->ptrRawFilterHistoryLow[sensorId];
            }
        
            ptrSnsCxt = &ptrWdCfg->ptrSnsContext[sensorId];
            cxtOffset = context->ptrCommonConfig->numSns;
            historyOffset = snsHistorySize * context->ptrCommonConfig->numSns;
            
            switch(ptrWdCfg->senseMethod)
            {
                case (uint8_t)CY_CAPSENSE_SENSE_METHOD_CSD_E:
                    for(freqChIndex = 0u; freqChIndex < freqChNumber; freqChIndex++)
                    {
                        result = Cy_CapSense_DpProcessCsdSensorRawCountsExt(
                                                ptrWdCfg,
                                                ptrSnsCxt, 
                                                ptrHistory,
                                                ptrHistoryLow,
                                                mode, context);
                        ptrSnsCxt += cxtOffset;
                        ptrHistory += historyOffset;
                        ptrHistoryLow += cxtOffset;
                    }
                    break;

                case (uint8_t)CY_CAPSENSE_SENSE_METHOD_CSX_E:
                    for(freqChIndex = 0u; freqChIndex < freqChNumber; freqChIndex++)
                    {    
                        result = Cy_CapSense_DpProcessCsxSensorRawCountsExt(
                                                ptrWdCfg,
                                                ptrSnsCxt, 
                                                ptrHistory,
                                                ptrHistoryLow,
                                                mode, context);
                        ptrSnsCxt += cxtOffset;
                        ptrHistory += historyOffset;
                        ptrHistoryLow += cxtOffset;                        
                    }
                    break;

                default:
                    CY_ASSERT(0 != 0);
                    break;
            }

            if(CY_CAPSENSE_ENABLE == context->ptrCommonConfig->mfsEn)
            {
                ptrSnsCxt = ptrWdCfg->ptrSnsContext;
                Cy_CapSense_RunMfsFiltering(ptrSnsCxt, context);
            }
            
            result = CY_RET_SUCCESS;
        }
    }
    return result;
}


/*******************************************************************************
* Function Name: Cy_CapSense_Wakeup
****************************************************************************//**
*
* Resumes the middleware after Deep Sleep.
*
* This function is used to resume the middleware after exiting Deep Sleep. In 
* Deep Sleep power mode, the CSD HW is powered off and an extra delay is required 
* to establish correct operation of HW.
*
* \param context
* The pointer to the CapSense context structure \ref cy_stc_capsense_context_t.
*
*******************************************************************************/
void Cy_CapSense_Wakeup(const cy_stc_capsense_context_t * context)
{
    Cy_SysLib_DelayUs((uint16_t)context->ptrCommonConfig->analogWakeupDelay);
}


/*******************************************************************************
* Function Name: Cy_CapSense_DeepSleepCallback
****************************************************************************//**
*
* Handles Active to Deep Sleep power mode transition for the CapSense
* middleware.
*
* Calling this function directly from the application layer is not recommended.
* Instead, Cy_SysPm_DeepSleep() should be used for the Active to Deep Sleep
* power mode transition of the device.
*
* For proper operation of the CapSense middleware during the Active to
* Deep Sleep mode transition, a callback to this function should be registered
* using the Cy_SysPm_RegisterCallback() function with CY_SYSPM_DEEPSLEEP
* type. After the callback is registered, this function is called by the
* Cy_SysPm_DeepSleep() function to prepare the middleware to the device
* power mode transition.
*
* When this function is called with CY_SYSPM_CHECK_READY as input, this
* function returns CY_SYSPM_SUCCESS if no scanning is in progress. Otherwise
* CY_SYSPM_FAIL is returned. If CY_SYSPM_FAIL status is returned, a device
* cannot change the power mode without completing the current scan as
* a transition to Deep Sleep during the scan can disrupt the middleware
* operation.
*
* \param callbackParams
* Refer to the description of the cy_stc_syspm_callback_params_t type in the
* Peripheral Driver Library documentation.
*
* \param mode
* Specifies mode cy_en_syspm_callback_mode_t.
*
* \return
* Returns the status cy_en_syspm_status_t of the operation requested 
* by the mode parameter:
* - CY_SYSPM_SUCCESS  - Deep Sleep power mode can be entered.
* - CY_SYSPM_FAIL     - Deep Sleep power mode cannot be entered.
*
*******************************************************************************/
cy_en_syspm_status_t Cy_CapSense_DeepSleepCallback(
                cy_stc_syspm_callback_params_t * callbackParams, 
                cy_en_syspm_callback_mode_t mode)
{
    cy_en_syspm_status_t retVal = CY_SYSPM_SUCCESS;
    cy_en_csd_key_t mwKey;
    cy_stc_capsense_context_t * capsenseCxt = (cy_stc_capsense_context_t *)callbackParams->context;

    if (CY_SYSPM_CHECK_READY == mode)
    {
        mwKey = Cy_CSD_GetLockStatus(capsenseCxt->ptrCommonConfig->ptrCsdBase, capsenseCxt->ptrCommonConfig->ptrCsdContext);

        if (CY_CSD_CAPSENSE_KEY == mwKey)
        {
            if (CY_CAPSENSE_NOT_BUSY != Cy_CapSense_IsBusy(capsenseCxt))
            {
                retVal = CY_SYSPM_FAIL;
            }
        }
    }

    return(retVal);
}


/*******************************************************************************
* Function Name: Cy_CapSense_IncrementGestureTimestamp
****************************************************************************//**
*
* Increases the timestamp register for the predefined timestamp interval.
*
* This function increments the timestamp by the interval specified
* in the context->ptrCommonContext->timestampInterval register. The unit for
* both parameters is milliseconds and default value of the interval is 1.
*
* The application layer must periodically call this
* function or register a periodic callback to this function to keep the
* timestamp updated and operational, which is vital for the
* operation of Gesture and Ballistic multiplier features.
*
* The timestamp can be updated in one of the three methods:
* - Register a periodic callback for the
*   Cy_CapSense_IncrementGestureTimestamp() function.
* - Periodically call the Cy_CapSense_IncrementGestureTimestamp() function
*   from the application layer.
* - Directly modify the timestamp using the
*   Cy_CapSense_SetGestureTimestamp() function.
*
* The interval at which this function is called should match with interval
* defined in context->ptrCommonContext->timestampInterval register. Either the
* register value can be updated to match the callback interval or the callback
* can be made at interval set in the register.
*
* If a timestamp is available from another source or from the Host controller,
* the application layer may choose to periodically update the timestamp
* by using Cy_CapSense_SetGestureTimestamp() function instead of
* registering a callback.
*
* \param context
* The pointer to the CapSense context structure \ref cy_stc_capsense_context_t.
*
*******************************************************************************/
void Cy_CapSense_IncrementGestureTimestamp(cy_stc_capsense_context_t * context)
{
    context->ptrCommonContext->timestamp += 
                context->ptrCommonContext->timestampInterval;
}


/*******************************************************************************
* Function Name: Cy_CapSense_SetGestureTimestamp
****************************************************************************//**
*
* Rewrites the timestamp register by the specified value.
*
* This function writes the specified value into the middleware timestamp 
* context->ptrCommonContext->timestamp register.
*
* If a timestamp is available from another source or from the Host controller,
* the application layer may choose to periodically update the timestamp
* by using this function instead of registering a callback.
*
* Do not modify the timestamp arbitrarily or
* simultaneously use with the Cy_CapSense_IncrementGestureTimestamp()
* function.
*
* \param value
* Specifies the timestamp value (in ms).
*
* \param context
* The pointer to the CapSense context structure \ref cy_stc_capsense_context_t.
*
*******************************************************************************/
void Cy_CapSense_SetGestureTimestamp(
                uint32_t value, 
                cy_stc_capsense_context_t * context)
{
    context->ptrCommonContext->timestamp = value;
}


/*******************************************************************************
* Function Name: Cy_CapSense_Restore
****************************************************************************//**
*
* Resumes the middleware operation if the Cy_CapSense_Save() function was
* called previously.
*
* This function performs a sub-set of initialization task to restore CapSense
* after underlying hardware are used by another middleware.
*
* \param context
* The pointer to the CapSense context structure \ref cy_stc_capsense_context_t.
*
* \return
* Returns the status of the resume process. If CY_RET_SUCCESS is not received,
* the resume process fails and retries may be required.
*
*******************************************************************************/
cy_status Cy_CapSense_Restore(cy_stc_capsense_context_t * context)
{
    uint32_t cpuFreqMHz;
    uint32_t watchdogCounter;

    cy_en_csd_key_t mvKey;
    cy_status result = CY_RET_INVALID_STATE;
    cy_en_csd_status_t csdHwStatus = CY_CSD_SUCCESS;
    cy_stc_csd_context_t * ptrCsdCxt = context->ptrCommonConfig->ptrCsdContext;
    CSD_Type * ptrCsdBaseAdd = context->ptrCommonConfig->ptrCsdBase;

    /* Approximate duration of Wait For Init loop */
    const uint32_t intrInitLoopDuration = 5uL;

    /* Wait For Init watchdog timeout in microseconds */
    const uint32_t initWatchdogTimeUs = 1000000uL;

    /* Get CSD HW block status */
    mvKey = Cy_CSD_GetLockStatus(ptrCsdBaseAdd, ptrCsdCxt);
    if(CY_CSD_NONE_KEY == mvKey)
    {
        csdHwStatus = Cy_CSD_GetConversionStatus(ptrCsdBaseAdd, ptrCsdCxt);
        if(CY_CSD_BUSY == csdHwStatus)
        {
            Cy_CSD_WriteReg(context->ptrCommonConfig->ptrCsdBase, CY_CSD_REG_OFFSET_INTR_MASK, CY_CAPSENSE_CSD_INTR_MASK_CLEAR_MSK);
            Cy_CSD_WriteReg(context->ptrCommonConfig->ptrCsdBase, CY_CSD_REG_OFFSET_SEQ_START, CY_CAPSENSE_CSD_SEQ_START_ABORT_MSK);

            /* Init Watchdog Counter to prevent a hang */
            cpuFreqMHz = context->ptrCommonConfig->cpuClkHz / 1000000uL;
            watchdogCounter = Cy_CapSense_WatchdogCyclesNum(initWatchdogTimeUs, cpuFreqMHz, intrInitLoopDuration);
            while((CY_CSD_BUSY == csdHwStatus) && (0uL != watchdogCounter))
            {
                csdHwStatus = Cy_CSD_GetConversionStatus(ptrCsdBaseAdd, ptrCsdCxt);
                watchdogCounter--;
            }
        }

        if(CY_CSD_SUCCESS == csdHwStatus)
        {
            csdHwStatus = Cy_CSD_Init(
                                ptrCsdBaseAdd, 
                                &cy_capsense_csdCfg, 
                                CY_CSD_CAPSENSE_KEY, 
                                ptrCsdCxt);
            result = CY_RET_SUCCESS;
        }
        
    }
    return (result);
}


/*******************************************************************************
* Function Name: Cy_CapSense_Save
****************************************************************************//**
*
* Saves the state of CapSense so the functionality can be restored
* using Cy_CapSense_Restore() function.
*
* When different functionality of the CSD block is required, this function is  
* used to switch the CSD block assignment between different middleware in 
* time-multiplexed mode. 
* This function performs the following operations:
* - Release CSD hardware block.
* - Configure sensor pins to the default state and disconnect them from 
*   analog buses.
* - Disconnect external capacitors from analog buses.
*
* \param context
* The pointer to the CapSense context structure \ref cy_stc_capsense_context_t.
*
* \return
* Returns the status of the process. If CY_RET_SUCCESS is not received,
* the save process fails and retries may be required.
*
*******************************************************************************/
cy_status Cy_CapSense_Save(cy_stc_capsense_context_t * context)
{
    cy_status result = CY_RET_INVALID_STATE;
    cy_en_csd_status_t initStatus = CY_CSD_LOCKED;

    if (CY_CAPSENSE_SW_STS_BUSY != Cy_CapSense_IsBusy(context))
    {
        /* Disconnect external capacitors and sensor pins from analog bus */
        Cy_CapSense_SwitchSensingMode((uint8_t)CY_CAPSENSE_UNDEFINED_E, context);

        /* Release HW CSD block */
        initStatus = Cy_CSD_DeInit(
                        context->ptrCommonConfig->ptrCsdBase, 
                        CY_CSD_CAPSENSE_KEY, 
                        context->ptrCommonConfig->ptrCsdContext);

        if (CY_CSD_SUCCESS == initStatus)
        {
            result = CY_RET_SUCCESS;

        }
    }

    return result;
}


/*******************************************************************************
* Function Name: Cy_CapSense_RegisterCallback
****************************************************************************//**
*
* Registers a callback function, which notifies that
* \ref cy_en_capsense_callback_event_t occurred in the CapSense middleware.
*
* \param callbackType
* The registered callback will be triggered with the CapSense middleware execution event.
* Refer to \ref cy_en_capsense_callback_event_t for the list of
* supported events.
*
* \param callbackFunction
* The pointer to the callback function.
*
* \param context
* The pointer to the CapSense context structure \ref cy_stc_capsense_context_t.
*
* \return
* Returns the status of the sensor process operation:
* - CY_RET_SUCCESS      - The processing performed successfully.
* - CY_RET_BAD_PARAM    - The input parameter is invalid.
*
*******************************************************************************/
cy_status Cy_CapSense_RegisterCallback(
                cy_en_capsense_callback_event_t callbackType,
                cy_capsense_callback_t callbackFunction,
                cy_stc_capsense_context_t * context)
{
    cy_status retVal = CY_RET_SUCCESS;
        
    if((NULL != callbackFunction) && (NULL != context))
    {
        switch(callbackType)
        {
            case CY_CAPSENSE_START_SAMPLE_E:
                context->ptrCommonContext->ptrSSCallback = callbackFunction;
                break;
            case CY_CAPSENSE_END_OF_SCAN_E:
                context->ptrCommonContext->ptrEOSCallback = callbackFunction;
                break;
            default:
                retVal = CY_RET_BAD_PARAM;
                break;
        }
    }
    else
    {
        retVal = CY_RET_BAD_PARAM;
    }

    return(retVal);
}


/*******************************************************************************
* Function Name: Cy_CapSense_UnRegisterCallback
****************************************************************************//**
*
* This function unregisters the CapSense middleware callbacks.
*
* \param callbackType
* The registered callback will be triggered with the CapSense middleware execution event. 
* Refer to \ref cy_en_capsense_callback_event_t for the list of
* supported events.
*
* \param context
* The pointer to the CapSense context structure \ref cy_stc_capsense_context_t.
*
* \return
* Returns the status of the sensor process operation:
* - CY_RET_SUCCESS      - The processing performed successfully.
* - CY_RET_BAD_PARAM    - The input parameter is invalid.
*
*******************************************************************************/
cy_status Cy_CapSense_UnRegisterCallback(
                cy_en_capsense_callback_event_t callbackType,
                cy_stc_capsense_context_t * context)
{
    cy_status retVal = CY_RET_SUCCESS;
        
    if(NULL != context)
    {
        switch(callbackType)
        {
            case CY_CAPSENSE_START_SAMPLE_E:
                context->ptrCommonContext->ptrSSCallback = NULL;
                break;
            case CY_CAPSENSE_END_OF_SCAN_E:
                context->ptrCommonContext->ptrEOSCallback = NULL;
                break;
            default:
                retVal = CY_RET_BAD_PARAM;
                break;
        }
    }
    else
    {
        retVal = CY_RET_BAD_PARAM;
    }

    return(retVal);

}


/* [] END OF FILE */
