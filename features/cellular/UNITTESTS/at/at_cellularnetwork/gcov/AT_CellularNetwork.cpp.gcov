        -:    0:Source:../../../framework/AT/AT_CellularNetwork.cpp
        -:    0:Graph:objs/AT_CellularNetwork_unit/AT_CellularNetwork.gcno
        -:    0:Data:objs/AT_CellularNetwork_unit/AT_CellularNetwork.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/*
        -:    2: * Copyright (c) 2017, Arm Limited and affiliates.
        -:    3: * SPDX-License-Identifier: Apache-2.0
        -:    4: *
        -:    5: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    6: * you may not use this file except in compliance with the License.
        -:    7: * You may obtain a copy of the License at
        -:    8: *
        -:    9: *     http://www.apache.org/licenses/LICENSE-2.0
        -:   10: *
        -:   11: * Unless required by applicable law or agreed to in writing, software
        -:   12: * distributed under the License is distributed on an "AS IS" BASIS,
        -:   13: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   14: * See the License for the specific language governing permissions and
        -:   15: * limitations under the License.
        -:   16: */
        -:   17:
        -:   18:#include <stdlib.h>
        -:   19:#include "AT_CellularNetwork.h"
        -:   20:#include "nsapi_ppp.h"
        -:   21:#include "CellularUtil.h"
        -:   22:#include "CellularLog.h"
        -:   23:
        -:   24:using namespace std;
        -:   25:using namespace mbed_cellular_util;
        -:   26:using namespace mbed;
        -:   27:
       25:   28:AT_CellularNetwork::AT_CellularNetwork(ATHandler &atHandler) : AT_CellularBase(atHandler),
        -:   29:    _stack(NULL), _uname(NULL), _pwd(NULL), _ip_stack_type_requested(DEFAULT_STACK), _ip_stack_type(DEFAULT_STACK), _cid(-1),
       25:   30:    _op_act(operator_t::RAT_UNKNOWN), _authentication_type(CHAP), _last_reg_type(C_REG)
        -:   31:{
        -:   32:
       25:   33:    _at.set_urc_handler("NO CARRIER", callback(this, &AT_CellularNetwork::urc_no_carrier));
        -:   34:
       25:   35:    memset(_apn, 0, MAX_APN_LENGTH);
        -:   36:
        -:   37:#ifdef MBED_CONF_APP_CELLULAR_APN
        -:   38:    strncpy(_apn, MBED_CONF_APP_CELLULAR_APN, MAX_APN_LENGTH);
        -:   39:    log_debug("Using APN [%s] from json", _apn);
        -:   40:#endif
        -:   41:
       25:   42:}
        -:   43:
       26:   44:AT_CellularNetwork::~AT_CellularNetwork()
        -:   45:{
       26:   46:}
        -:   47:
        1:   48:void AT_CellularNetwork::urc_no_carrier()
        -:   49:{
        1:   50:    if (_connection_status_cb) {
        1:   51:        _connection_status_cb(NSAPI_ERROR_CONNECTION_LOST);
        -:   52:    }
        1:   53:}
        -:   54:
        1:   55:nsapi_error_t AT_CellularNetwork::set_credentials(const char *apn,
        -:   56:        const char *username, const char *password)
        -:   57:{
        1:   58:    strncpy(_apn, apn, MAX_APN_LENGTH);
        1:   59:    _uname = username;
        1:   60:    _pwd = password;
        -:   61:
        1:   62:    return NSAPI_ERROR_OK;
        -:   63:}
        -:   64:
        1:   65:nsapi_error_t AT_CellularNetwork::set_credentials(const char *apn,
        -:   66:     AuthenticationType type, const char *username, const char *password)
        -:   67:{
        1:   68:    strncpy(_apn, apn, MAX_APN_LENGTH);
        1:   69:    _uname = username;
        1:   70:    _pwd = password;
        1:   71:    _authentication_type = type;
        -:   72:
        1:   73:    return NSAPI_ERROR_OK;
        -:   74:}
        -:   75:
        2:   76:nsapi_error_t AT_CellularNetwork::connect(const char *apn,
        -:   77:        const char *username, const char *password)
        -:   78:{
        2:   79:    strncpy(_apn, apn, MAX_APN_LENGTH);
        2:   80:    _uname = username;
        2:   81:    _pwd = password;
        -:   82:
        2:   83:    return connect();
        -:   84:}
        -:   85:
        2:   86:nsapi_error_t AT_CellularNetwork::connect()
        -:   87:{
        2:   88:    _at.lock();
        -:   89:
        2:   90:    nsapi_error_t err = set_context_to_be_activated();
        2:   91:    if (err != NSAPI_ERROR_OK) {
        1:   92:        _at.unlock();
        1:   93:        log_error("Failed to activate network context!");
        1:   94:        return err;
        -:   95:    }
        -:   96:
        1:   97:    err = open_data_channel();
        1:   98:    if (err != NSAPI_ERROR_OK) {
        1:   99:        _at.unlock();
        1:  100:        log_error("Failed to open data channel!");
        1:  101:        return err;
        -:  102:    }
        -:  103:
    #####:  104:    _at.unlock();
        -:  105:
    #####:  106:    return NSAPI_ERROR_OK;
        -:  107:}
        -:  108:
        1:  109:nsapi_error_t AT_CellularNetwork::open_data_channel()
        -:  110:{
        -:  111:    //old way: _at.send("ATD*99***%d#", _cid) && _at.recv("CONNECT");
        1:  112:    nsapi_error_t err = NSAPI_ERROR_NO_CONNECTION;
        -:  113:#if NSAPI_PPP_AVAILABLE
        -:  114:    log_info("Open data channel in PPP mode");
        -:  115:    _at.cmd_start("AT+CGDATA=\"PPP\",");
        -:  116:    _at.write_int(_cid);
        -:  117:    _at.cmd_stop();
        -:  118:
        -:  119:    _at.resp_start("CONNECT", true);
        -:  120:    if (_at.get_last_error()) {
        -:  121:        log_warn("Failed to CONNECT");
        -:  122:    }
        -:  123:    /* Initialize PPP
        -:  124:     * mbed_ppp_init() is a blocking call, it will block until
        -:  125:     * connected, or timeout after 30 seconds*/
        -:  126:    err = nsapi_ppp_connect(_at.get_file_handle(), _connection_status_cb, _uname, _pwd, _ip_stack_type);
        -:  127:#else
        -:  128:    // do check for stack to validate that we have support for stack
        1:  129:    _stack = get_stack();
        1:  130:    if (!_stack) {
        1:  131:        return err;
        -:  132:    }
        -:  133:
    #####:  134:    bool is_context_active = false;
    #####:  135:    _at.cmd_start("AT+CGACT?");
    #####:  136:    _at.cmd_stop();
    #####:  137:    _at.resp_start("+CGACT:");
    #####:  138:    while (_at.info_resp()) {
    #####:  139:        int context_id = _at.read_int();
    #####:  140:        int context_activation_state = _at.read_int();
    #####:  141:        if (context_id == _cid && context_activation_state == 1) {
    #####:  142:            is_context_active = true;
        -:  143:        }
        -:  144:    }
    #####:  145:    _at.resp_stop();
        -:  146:
    #####:  147:    if (!is_context_active) {
        -:  148:        log_info("Activate PDP context");
    #####:  149:        _at.cmd_start("AT+CGACT=1,");
    #####:  150:        _at.write_int(_cid);
    #####:  151:        _at.cmd_stop();
    #####:  152:        _at.resp_start();
    #####:  153:        _at.resp_stop();
        -:  154:    }
        -:  155:
    #####:  156:    err = (_at.get_last_error() == NSAPI_ERROR_OK) ? NSAPI_ERROR_OK : NSAPI_ERROR_NO_CONNECTION;
        -:  157:#endif
    #####:  158:    return err;
        -:  159:}
        -:  160:
        -:  161:/**
        -:  162: * User initiated disconnect
        -:  163: *
        -:  164: * Disconnects from PPP connection only and brings down the underlying network
        -:  165: * interface
        -:  166: */
        1:  167:nsapi_error_t AT_CellularNetwork::disconnect()
        -:  168:{
        -:  169:#if NSAPI_PPP_AVAILABLE
        -:  170:    return nsapi_ppp_disconnect(_at.get_file_handle());
        -:  171:#else
        1:  172:    return NSAPI_ERROR_OK;
        -:  173:#endif
        -:  174:}
        -:  175:
        1:  176:void AT_CellularNetwork::connection_status_cb(Callback<void(nsapi_error_t)> cb)
        -:  177:{
        1:  178:    _connection_status_cb = cb;
        1:  179:}
        -:  180:
        2:  181:nsapi_error_t AT_CellularNetwork::set_context_to_be_activated()
        -:  182:{
        -:  183:    // try to find or create context with suitable stack
        2:  184:    if (!get_context(_ip_stack_type_requested)) {
        1:  185:        return NSAPI_ERROR_NO_CONNECTION;
        -:  186:    }
        -:  187:
        -:  188:    // if user has defined user name and password we need to call CGAUTH before activating or modifying context
        1:  189:    if (_pwd && _uname) {
        1:  190:        _at.cmd_start("AT+CGAUTH=");
        1:  191:        _at.write_int(_cid);
        1:  192:        _at.write_int(_authentication_type);
        1:  193:        _at.write_string(_uname);
        1:  194:        _at.write_string(_pwd);
        1:  195:        _at.cmd_stop();
        1:  196:        _at.resp_start();
        1:  197:        _at.resp_stop();
        1:  198:        if (_at.get_last_error() != NSAPI_ERROR_OK) {
    #####:  199:            return NSAPI_ERROR_AUTH_FAILURE;
        -:  200:        }
        -:  201:    }
        -:  202:
        1:  203:    return _at.get_last_error();
        -:  204:}
        -:  205:
        2:  206:bool AT_CellularNetwork::set_new_context(nsapi_ip_stack_t stack, int cid)
        -:  207:{
        2:  208:    nsapi_ip_stack_t tmp_stack = stack;
        2:  209:    char pdp_type[8+1] = {0};
        -:  210:
        2:  211:    switch (stack) {
        -:  212:        case IPV4_STACK:
    #####:  213:            strncpy(pdp_type, "IP", sizeof(pdp_type));
    #####:  214:            break;
        -:  215:        case IPV6_STACK:
    #####:  216:            strncpy(pdp_type, "IPV6", sizeof(pdp_type));
    #####:  217:            break;
        -:  218:        case IPV4V6_STACK:
    #####:  219:            strncpy(pdp_type, "IPV4V6", sizeof(pdp_type));
    #####:  220:            break;
        -:  221:        default:
        2:  222:            strncpy(pdp_type, "", sizeof(pdp_type));
        2:  223:            break;
        -:  224:    }
        -:  225:
        -:  226:    //apn: "If the value is null or omitted, then the subscription value will be requested."
        2:  227:    bool success = false;
        2:  228:    _at.cmd_start("AT+CGDCONT=");
        2:  229:    _at.write_int(cid);
        2:  230:    _at.write_string(pdp_type);
        2:  231:    _at.write_string(_apn);
        2:  232:    _at.cmd_stop();
        2:  233:    _at.resp_start();
        2:  234:    _at.resp_stop();
        2:  235:    success = (_at.get_last_error() == NSAPI_ERROR_OK);
        -:  236:
        -:  237:    // Fall back to ipv4
        2:  238:    if (!success && tmp_stack == IPV4V6_STACK) {
    #####:  239:        tmp_stack = IPV4_STACK;
    #####:  240:        _at.cmd_start("AT+FCLASS=0;+CGDCONT=");
    #####:  241:        _at.write_int(cid);
    #####:  242:        _at.write_string("IP");
    #####:  243:        _at.write_string(_apn);
    #####:  244:        _at.cmd_stop();
    #####:  245:        _at.resp_start();
    #####:  246:        _at.resp_stop();
    #####:  247:        success = (_at.get_last_error() == NSAPI_ERROR_OK);
        -:  248:    }
        -:  249:
        2:  250:    if (success) {
        1:  251:        _ip_stack_type = tmp_stack;
        1:  252:        _cid = cid;
        -:  253:    }
        -:  254:
        2:  255:  return success;
        -:  256:}
        -:  257:
        2:  258:bool AT_CellularNetwork::get_context(nsapi_ip_stack_t requested_stack)
        -:  259:{
        2:  260:    _at.cmd_start("AT+CGDCONT?");
        2:  261:    _at.cmd_stop();
        2:  262:    _at.resp_start("+CGDCONT:");
        2:  263:    _cid = -1;
        2:  264:    int cid_max = 0; // needed when creating new context
        2:  265:    char apn[MAX_APN_LENGTH] = {0};
        2:  266:    int apn_len = 0;
        -:  267:
        2:  268:    while (_at.info_resp()) {
    #####:  269:        int cid = _at.read_int();
    #####:  270:        if (cid > cid_max) {
    #####:  271:            cid_max = cid;
        -:  272:        }
        -:  273:        char pdp_type_from_context[10];
    #####:  274:        int pdp_type_len = _at.read_string(pdp_type_from_context, sizeof(pdp_type_from_context) - 1);
    #####:  275:        if (pdp_type_len > 0) {
    #####:  276:            apn_len = _at.read_string(apn, sizeof(apn) - 1);
    #####:  277:            if (apn_len >= 0) {
    #####:  278:                if (strlen(_apn) && strcmp(apn, _apn) != 0 ) {
    #####:  279:                    continue;
        -:  280:                }
    #####:  281:                nsapi_ip_stack_t pdp_stack = string_to_stack_type(pdp_type_from_context);
    #####:  282:                if (pdp_stack != DEFAULT_STACK) {
    #####:  283:                    if (get_modem_stack_type(pdp_stack)) {
    #####:  284:                        if (requested_stack == IPV4_STACK) {
    #####:  285:                            if (pdp_stack == IPV4_STACK || pdp_stack == IPV4V6_STACK) {
    #####:  286:                                _ip_stack_type = requested_stack;
    #####:  287:                                _cid = cid;
    #####:  288:                                break;
        -:  289:                            }
    #####:  290:                        } else if (requested_stack == IPV6_STACK) {
    #####:  291:                            if (pdp_stack == IPV6_STACK || pdp_stack == IPV4V6_STACK) {
    #####:  292:                                _ip_stack_type = requested_stack;
    #####:  293:                                _cid = cid;
    #####:  294:                                break;
        -:  295:                            }
        -:  296:                        } else { // accept any but prefer to IPv6
    #####:  297:                            if (pdp_stack == IPV6_STACK || pdp_stack == IPV4V6_STACK) {
    #####:  298:                                _ip_stack_type = requested_stack;
    #####:  299:                                _cid = cid;
    #####:  300:                                break;
        -:  301:                            }
    #####:  302:                            if (_ip_stack_type == DEFAULT_STACK) {
    #####:  303:                                _ip_stack_type = pdp_stack;
    #####:  304:                                _cid = cid;
        -:  305:                            }
        -:  306:                        }
        -:  307:                    }
        -:  308:                }
        -:  309:            }
        -:  310:        }
        -:  311:    }
        2:  312:    _at.resp_stop();
        2:  313:    if (_cid == -1) { // no suitable context was found so create a new one
        2:  314:        if (!set_new_context(_ip_stack_type, cid_max+1)) {
        1:  315:            return false;
        -:  316:        }
        -:  317:    }
        -:  318:
        -:  319:    // save the apn
        1:  320:    if (apn_len > 0 && !strlen(_apn)) {
    #####:  321:        strncpy(_apn, apn, MAX_APN_LENGTH);
        -:  322:    }
        -:  323:
        -:  324:    log_debug("Context id %d", _cid);
        1:  325:    return true;
        -:  326:}
        -:  327:
    #####:  328:nsapi_ip_stack_t AT_CellularNetwork::string_to_stack_type(const char* pdp_type)
        -:  329:{
    #####:  330:    nsapi_ip_stack_t stack = DEFAULT_STACK;
    #####:  331:    int len = strlen(pdp_type);
        -:  332:
    #####:  333:    if (len == 6 && memcmp(pdp_type, "IPV4V6", len) == 0) {
    #####:  334:        stack = IPV4V6_STACK;
    #####:  335:    } else if (len == 4 && memcmp(pdp_type, "IPV6", len) == 0) {
    #####:  336:        stack = IPV6_STACK;
    #####:  337:    } else if (len == 2 && memcmp(pdp_type, "IP", len) == 0) {
    #####:  338:        stack = IPV4_STACK;
        -:  339:    }
    #####:  340:    return stack;
        -:  341:}
        -:  342:
        1:  343:nsapi_error_t AT_CellularNetwork::set_registration_urc(bool urc_on)
        -:  344:{
        1:  345:    RegistrationType reg_types[] = {C_EREG,        C_GREG,       C_REG};
        1:  346:    const char *cmd_on[]  =       {"AT+CEREG=2",   "AT+CGREG=2",    "AT+CREG=2"};
        1:  347:    const char *cmd_off[] =       {"AT+CEREG=0",   "AT+CGREG=0",    "AT+CREG=0"};
        4:  348:    for (uint8_t i=0; i<sizeof(reg_types)/sizeof(reg_types[0]); i++) {
        3:  349:        if (has_registration(reg_types[i])) {
        3:  350:            _last_reg_type = reg_types[i];
        3:  351:            if (urc_on) {
    #####:  352:                _at.cmd_start(cmd_on[i]);
    #####:  353:                _at.cmd_stop();
        -:  354:            } else {
        3:  355:                _at.cmd_start(cmd_off[i]);
        3:  356:                _at.cmd_stop();
        -:  357:            }
        -:  358:
        3:  359:            _at.resp_start();
        3:  360:            _at.resp_stop();
        -:  361:        }
        -:  362:    }
        1:  363:    return _at.get_last_error();
        -:  364:}
        -:  365:
        1:  366:nsapi_error_t AT_CellularNetwork::set_registration(char *plmn)
        -:  367:{
        1:  368:    _at.lock();
        -:  369:
        1:  370:    nsapi_error_t ret = set_registration_urc(false);
        1:  371:    if (ret) {
        1:  372:        log_error("Setting registration URC failed!");
        1:  373:        _at.clear_error(); // allow temporary failures here
        -:  374:    }
        -:  375:
        1:  376:    if (!plmn) {
        -:  377:        log_debug("Automatic network registration");
        1:  378:        _at.cmd_start("AT+COPS=0");
        1:  379:        _at.cmd_stop();
        1:  380:        _at.resp_start();
        1:  381:        _at.resp_stop();
        -:  382:    } else {
        -:  383:        log_debug("Manual network registration to %s", plmn);
    #####:  384:        _at.cmd_start("AT+COPS=4,2,");
    #####:  385:        _at.write_string(plmn);
    #####:  386:        _at.cmd_stop();
    #####:  387:        _at.resp_start();
    #####:  388:        _at.resp_stop();
        -:  389:    }
        -:  390:
        1:  391:    return _at.unlock_return_error();
        -:  392:}
        -:  393:
        2:  394:nsapi_error_t AT_CellularNetwork::get_registration_status(RegistrationType type, RegistrationStatus &status)
        -:  395:{
        2:  396:    int i = (int)type;
        2:  397:    MBED_ASSERT(i >= 0 && i < C_MAX);
        -:  398:
        2:  399:    RegistrationType reg_types[] = { C_EREG,       C_GREG,       C_REG};
        2:  400:    const char *cmd[] =            { "AT+CEREG",   "AT+CGREG",    "AT+CREG"};
        2:  401:    const char *rsp[] =            { "+CEREG: ",    "+CGREG: ",     "+CREG: "};
        -:  402:
        2:  403:    const int LAC_LENGTH = 5, CELL_ID_LENGTH = 9;
        2:  404:    char lac_string[LAC_LENGTH] = {0}, cell_id_string[CELL_ID_LENGTH] = {0};
        2:  405:    bool lac_read = false, cell_id_read = false;
        -:  406:
        2:  407:    _cell_id = -1;
        2:  408:    _lac = -1;
        -:  409:
        2:  410:     _at.lock();
        -:  411:
        2:  412:    if (!has_registration(reg_types[i])) {
    #####:  413:        _at.unlock();
    #####:  414:        return NSAPI_ERROR_UNSUPPORTED;
        -:  415:    }
        -:  416:
        2:  417:    _at.cmd_start(cmd[i]);
        2:  418:    _at.write_string("=2", false);
        2:  419:    _at.cmd_stop();
        2:  420:    _at.resp_start();
        2:  421:    _at.resp_stop();
        -:  422:
        2:  423:    _at.cmd_start(cmd[i]);
        2:  424:    _at.write_string("?", false);
        -:  425:
        2:  426:    _at.cmd_stop();
        2:  427:    _at.resp_start(rsp[i]);
        2:  428:    _at.read_int(); // ignore urc mode subparam
        2:  429:    status = (RegistrationStatus)_at.read_int();
        -:  430:
        2:  431:    int len = _at.read_string(lac_string, LAC_LENGTH);
        2:  432:    if (memcmp(lac_string, "ffff", LAC_LENGTH-1) && len >= 0) {
        2:  433:        lac_read = true;
        -:  434:    }
        -:  435:
        2:  436:    len = _at.read_string(cell_id_string, CELL_ID_LENGTH);
        2:  437:    if (memcmp(cell_id_string, "ffffffff", CELL_ID_LENGTH-1) && len >= 0) {
        2:  438:        cell_id_read = true;
        -:  439:    }
        -:  440:
        2:  441:    _AcT = (operator_t::RadioAccessTechnology)_at.read_int();
        -:  442:
        2:  443:    _at.resp_stop();
        -:  444:
        2:  445:    _at.cmd_start(cmd[i]);
        2:  446:    _at.write_string("=0", false);
        2:  447:    _at.cmd_stop();
        2:  448:    _at.resp_start();
        2:  449:    _at.resp_stop();
        2:  450:    nsapi_error_t ret = _at.get_last_error();
        2:  451:    _at.unlock();
        -:  452:
        2:  453:    if (lac_read) {
        2:  454:        _lac = hex_str_to_int(lac_string, LAC_LENGTH);
        -:  455:        log_debug("lac %s %d", lac_string, _lac );
        -:  456:    }
        -:  457:
        2:  458:    if (cell_id_read) {
        2:  459:        _cell_id = hex_str_to_int(cell_id_string, CELL_ID_LENGTH);
        -:  460:        log_debug("cell_id %s %d", cell_id_string, _cell_id );
        -:  461:    }
        -:  462:
        2:  463:    return ret;
        -:  464:}
        -:  465:
        1:  466:nsapi_error_t AT_CellularNetwork::get_cell_id(int &cell_id)
        -:  467:{
        -:  468:    RegistrationStatus tmp;
        -:  469:
        1:  470:    nsapi_error_t error = get_registration_status(_last_reg_type, tmp);
        -:  471:
        1:  472:    cell_id = _cell_id;
        -:  473:
        1:  474:    return error;
        -:  475:}
        -:  476:
        5:  477:bool AT_CellularNetwork::has_registration(RegistrationType reg_type)
        -:  478:{
        -:  479:    (void)reg_type;
        5:  480:    return true;
        -:  481:}
        -:  482:
        1:  483:nsapi_error_t AT_CellularNetwork::set_attach(int timeout)
        -:  484:{
        1:  485:    _at.lock();
        -:  486:
        1:  487:    _at.cmd_start("AT+CGATT?");
        1:  488:    _at.cmd_stop();
        1:  489:    _at.resp_start("+CGATT:");
        1:  490:    int attached_state = _at.read_int();
        1:  491:    _at.resp_stop();
        1:  492:    if (attached_state != 1) {
        -:  493:        log_debug("Network attach");
        1:  494:        _at.cmd_start("AT+CGATT=1");
        1:  495:        _at.cmd_stop();
        1:  496:        _at.resp_start();
        1:  497:        _at.resp_stop();
        -:  498:    }
        -:  499:
        1:  500:    return _at.unlock_return_error();
        -:  501:}
        -:  502:
        1:  503:nsapi_error_t AT_CellularNetwork::get_attach(AttachStatus &status)
        -:  504:{
        1:  505:    _at.lock();
        -:  506:
        1:  507:    _at.cmd_start("AT+CGATT?");
        1:  508:    _at.cmd_stop();
        -:  509:
        1:  510:    _at.resp_start("+CGATT:");
        1:  511:    if (_at.info_resp()) {
    #####:  512:        int attach_status = _at.read_int();
    #####:  513:        status = (attach_status == 1) ? Attached : Detached;
        -:  514:    }
        1:  515:    _at.resp_stop();
        -:  516:
        1:  517:    return _at.unlock_return_error();
        -:  518:}
        -:  519:
        -:  520:
        1:  521:nsapi_error_t AT_CellularNetwork::get_backoff_time(int &backoffTime)
        -:  522:{
        1:  523:    _at.lock();
        -:  524:
        -:  525:    // If apn is set
        1:  526:    if (strlen(_apn)) {
    #####:  527:        _at.cmd_start("AT+CABTRDP=");
    #####:  528:        _at.write_string(_apn);
    #####:  529:        _at.cmd_stop();
    #####:  530:        _at.resp_start("+CABTRDP:");
    #####:  531:        if (_at.info_resp()) {
    #####:  532:            _at.skip_param();
    #####:  533:            backoffTime = _at.read_int();
        -:  534:        }
    #####:  535:        _at.resp_stop();
        -:  536:    }
        -:  537:
        1:  538:    return _at.unlock_return_error();
        -:  539:}
        -:  540:
        3:  541:NetworkStack *AT_CellularNetwork::get_stack()
        -:  542:{
        -:  543:    // use lwIP/PPP if modem does not have IP stack
        -:  544:#if NSAPI_PPP_AVAILABLE
        -:  545:    _stack = nsapi_ppp_get_stack();
        -:  546:#else
        3:  547:    _stack = NULL;
        -:  548:#endif
        3:  549:    return _stack;
        -:  550:}
        -:  551:
        1:  552:const char *AT_CellularNetwork::get_ip_address()
        -:  553:{
        -:  554:#if NSAPI_PPP_AVAILABLE
        -:  555:    return nsapi_ppp_get_ip_addr(_at.get_file_handle());
        -:  556:#else
        1:  557:    if (!_stack) {
        1:  558:        _stack = get_stack();
        -:  559:    }
        1:  560:    if (_stack) {
    #####:  561:        return _stack->get_ip_address();
        -:  562:    }
        1:  563:    return NULL;
        -:  564:#endif
        -:  565:}
        -:  566:
        3:  567:nsapi_error_t AT_CellularNetwork::set_stack_type(nsapi_ip_stack_t stack_type)
        -:  568:{
        -:  569:
        3:  570:    if (get_modem_stack_type(stack_type)) {
        1:  571:        _ip_stack_type_requested = stack_type;
        1:  572:        return NSAPI_ERROR_OK;
        -:  573:    } else {
        2:  574:        return NSAPI_ERROR_PARAMETER;
        -:  575:    }
        -:  576:
        -:  577:}
        -:  578:
        1:  579:nsapi_ip_stack_t AT_CellularNetwork::get_stack_type()
        -:  580:{
        1:  581:    return _ip_stack_type;
        -:  582:}
        -:  583:
        3:  584:bool AT_CellularNetwork::get_modem_stack_type(nsapi_ip_stack_t requested_stack)
        -:  585:{
        3:  586:    if (requested_stack == _ip_stack_type) {
        1:  587:        return true;
        -:  588:    } else {
        2:  589:        return false;
        -:  590:    }
        -:  591:}
        -:  592:
        1:  593:nsapi_error_t AT_CellularNetwork::set_access_technology_impl(operator_t::RadioAccessTechnology opsAct)
        -:  594:{
        1:  595:    return NSAPI_ERROR_UNSUPPORTED;
        -:  596:}
        -:  597:
        2:  598:nsapi_error_t AT_CellularNetwork::set_access_technology(operator_t::RadioAccessTechnology opAct)
        -:  599:{
        2:  600:    if (opAct == operator_t::RAT_UNKNOWN) {
        1:  601:        return NSAPI_ERROR_UNSUPPORTED;
        -:  602:    }
        -:  603:
        1:  604:    _op_act = opAct;
        -:  605:
        1:  606:    return set_access_technology_impl(opAct);
        -:  607:}
        -:  608:
        1:  609:nsapi_error_t AT_CellularNetwork::scan_plmn(operList_t &operators, int &opsCount)
        -:  610:{
        1:  611:    int idx = 0;
        -:  612:
        1:  613:    _at.lock();
        -:  614:
        1:  615:    _at.cmd_start("AT+COPS=?");
        1:  616:    _at.cmd_stop();
        -:  617:
        1:  618:    _at.resp_start("+COPS:");
        -:  619:
        1:  620:    int ret, error_code = -1;
        1:  621:    operator_t *op = NULL;
        -:  622:
        1:  623:    while (_at.info_elem('(')) {
        -:  624:
    #####:  625:        op = operators.add_new();
        -:  626:
    #####:  627:        op->op_status = (operator_t::Status)_at.read_int();
    #####:  628:        _at.read_string(op->op_long, sizeof(op->op_long));
    #####:  629:        _at.read_string(op->op_short, sizeof(op->op_short));
    #####:  630:        _at.read_string(op->op_num, sizeof(op->op_num));
        -:  631:
        -:  632:        // Optional - try read an int
    #####:  633:        ret = _at.read_int();
    #####:  634:        op->op_rat = (ret == error_code) ? operator_t::RAT_UNKNOWN:(operator_t::RadioAccessTechnology)ret;
        -:  635:
    #####:  636:        if ((_op_act == operator_t::RAT_UNKNOWN) ||
    #####:  637:           ((op->op_rat != operator_t::RAT_UNKNOWN) && (op->op_rat == _op_act))) {
    #####:  638:            idx++;
        -:  639:        } else {
    #####:  640:            operators.delete_last();
        -:  641:        }
        -:  642:    }
        -:  643:
        1:  644:    _at.resp_stop();
        -:  645:
        1:  646:    opsCount = idx;
        -:  647:
        1:  648:    return _at.unlock_return_error();
        -:  649:}
        -:  650:
        1:  651:nsapi_error_t AT_CellularNetwork::set_ciot_optimization_config(Supported_UE_Opt supported_opt,
        -:  652:                                                               Preferred_UE_Opt preferred_opt)
        -:  653:{
        1:  654:    _at.lock();
        -:  655:
        1:  656:    _at.cmd_start("AT+CCIOTOPT=");
        1:  657:    _at.write_int(_cid);
        1:  658:    _at.write_int(supported_opt);
        1:  659:    _at.write_int(preferred_opt);
        1:  660:    _at.cmd_stop();
        -:  661:
        1:  662:    _at.resp_start();
        1:  663:    _at.resp_stop();
        -:  664:
        1:  665:    return _at.unlock_return_error();
        -:  666:}
        -:  667:
        1:  668:nsapi_error_t AT_CellularNetwork::get_ciot_optimization_config(Supported_UE_Opt& supported_opt,
        -:  669:                                                               Preferred_UE_Opt& preferred_opt)
        -:  670:{
        1:  671:    _at.lock();
        -:  672:
        1:  673:    _at.cmd_start("AT+CCIOTOPT?");
        1:  674:    _at.cmd_stop();
        -:  675:
        1:  676:    _at.resp_start("+CCIOTOPT:");
        1:  677:    _at.read_int();
        1:  678:    if (_at.get_last_error() == NSAPI_ERROR_OK) {
    #####:  679:        supported_opt = (Supported_UE_Opt)_at.read_int();
    #####:  680:        preferred_opt = (Preferred_UE_Opt)_at.read_int();
        -:  681:    }
        -:  682:
        1:  683:    _at.resp_stop();
        -:  684:
        1:  685:    return _at.unlock_return_error();
        -:  686:}
        -:  687:
        1:  688:nsapi_error_t AT_CellularNetwork::get_rate_control(
        -:  689:        CellularNetwork::RateControlExceptionReports &reports,
        -:  690:        CellularNetwork::RateControlUplinkTimeUnit &timeUnit, int &uplinkRate)
        -:  691:{
        -:  692:
        1:  693:    _at.lock();
        -:  694:
        1:  695:    _at.cmd_start("AT+CGAPNRC=");
        1:  696:    _at.write_int(_cid);
        1:  697:    _at.cmd_stop();
        -:  698:
        1:  699:    _at.resp_start("+CGAPNRC:");
        1:  700:    _at.read_int();
        1:  701:    if (_at.get_last_error() == NSAPI_ERROR_OK) {
        1:  702:        bool comma_found = true;
        1:  703:        int next_element = _at.read_int();
        1:  704:        if (next_element >= 0) {
    #####:  705:            reports = (RateControlExceptionReports)next_element;
        -:  706:            log_debug("reports %d",reports);
    #####:  707:            next_element = _at.read_int();
        -:  708:        } else {
        1:  709:            comma_found = false;
        -:  710:        }
        -:  711:
        1:  712:        if (comma_found && next_element >= 0) {
    #####:  713:            timeUnit = (RateControlUplinkTimeUnit)next_element;
        -:  714:            log_debug("time %d",timeUnit);
    #####:  715:            next_element = _at.read_int();
        -:  716:        } else {
        1:  717:            comma_found = false;
        -:  718:        }
        -:  719:
        1:  720:        if (comma_found && next_element >= 0) {
    #####:  721:            uplinkRate = next_element;
        -:  722:            log_debug("rate %d",uplinkRate);
        -:  723:        }
        -:  724:    }
        1:  725:    _at.resp_stop();
        1:  726:    nsapi_error_t ret = _at.get_last_error();
        1:  727:    _at.unlock();
        -:  728:
        1:  729:    return (ret == NSAPI_ERROR_OK) ? NSAPI_ERROR_OK : NSAPI_ERROR_PARAMETER;
        -:  730:}
        -:  731:
        1:  732:nsapi_error_t AT_CellularNetwork::get_pdpcontext_params(pdpContextList_t& params_list)
        -:  733:{
        1:  734:    const int ipv6_subnet_size = 128;
        1:  735:    const int max_ipv6_size = 64;
        1:  736:    char* ipv6_and_subnetmask = (char*)malloc(ipv6_subnet_size);
        1:  737:    if (!ipv6_and_subnetmask) {
    #####:  738:        return NSAPI_ERROR_NO_MEMORY;
        -:  739:    }
        -:  740:
        1:  741:    char* temp = (char*)malloc(max_ipv6_size);
        1:  742:    if (!temp) {
    #####:  743:        free(ipv6_and_subnetmask);
    #####:  744:        return NSAPI_ERROR_NO_MEMORY;
        -:  745:    }
        -:  746:
        1:  747:    _at.lock();
        -:  748:
        1:  749:    _at.cmd_start("AT+CGCONTRDP=");
        1:  750:    _at.write_int(_cid);
        1:  751:    _at.cmd_stop();
        -:  752:
        1:  753:    _at.resp_start("+CGCONTRDP:");
        1:  754:    pdpcontext_params_t *params = NULL;
        1:  755:    while (_at.info_resp()) { // response can be zero or many +CGDCONT lines
    #####:  756:        params = params_list.add_new();
    #####:  757:        if (!params) {
        -:  758:            log_warn("Could not allocate new pdpcontext_params_t");
    #####:  759:            params_list.delete_all();
    #####:  760:            _at.resp_stop();
    #####:  761:            free(temp);
    #####:  762:            free(ipv6_and_subnetmask);
    #####:  763:            return NSAPI_ERROR_NO_MEMORY;
        -:  764:        }
        -:  765:
    #####:  766:        params->cid = _at.read_int();
    #####:  767:        params->bearer_id = _at.read_int();
    #####:  768:        _at.read_string(params->apn, sizeof(params->apn));
        -:  769:
        -:  770:        // rest are optional params
    #####:  771:        ipv6_and_subnetmask[0] = '\0';
    #####:  772:        temp[0] = '\0';
    #####:  773:        _at.read_string(ipv6_and_subnetmask, ipv6_subnet_size);
    #####:  774:        separate_ip_addresses(ipv6_and_subnetmask, params->local_addr, sizeof(params->local_addr), params->local_subnet_mask, sizeof(params->local_subnet_mask));
    #####:  775:        ipv6_and_subnetmask[0] = '\0';
        -:  776:
    #####:  777:        _at.read_string(ipv6_and_subnetmask, ipv6_subnet_size);
    #####:  778:        separate_ip_addresses(ipv6_and_subnetmask, params->gateway_addr, sizeof(params->gateway_addr), temp, max_ipv6_size);
    #####:  779:        prefer_ipv6(params->gateway_addr, sizeof(params->gateway_addr), temp, max_ipv6_size);
    #####:  780:        ipv6_and_subnetmask[0] = '\0';
    #####:  781:        temp[0] = '\0';
        -:  782:
    #####:  783:        _at.read_string(ipv6_and_subnetmask, ipv6_subnet_size);
    #####:  784:        separate_ip_addresses(ipv6_and_subnetmask, params->dns_primary_addr, sizeof(params->dns_primary_addr), temp, max_ipv6_size);
    #####:  785:        prefer_ipv6(params->dns_primary_addr, sizeof(params->dns_primary_addr), temp, max_ipv6_size);
    #####:  786:        ipv6_and_subnetmask[0] = '\0';
    #####:  787:        temp[0] = '\0';
        -:  788:
    #####:  789:        _at.read_string(ipv6_and_subnetmask, ipv6_subnet_size);
    #####:  790:        separate_ip_addresses(ipv6_and_subnetmask, params->dns_secondary_addr, sizeof(params->dns_secondary_addr), temp, max_ipv6_size);
    #####:  791:        prefer_ipv6(params->dns_secondary_addr, sizeof(params->dns_secondary_addr), temp, max_ipv6_size);
    #####:  792:        ipv6_and_subnetmask[0] = '\0';
    #####:  793:        temp[0] = '\0';
        -:  794:
    #####:  795:        _at.read_string(ipv6_and_subnetmask, ipv6_subnet_size);
    #####:  796:        separate_ip_addresses(ipv6_and_subnetmask, params->p_cscf_prim_addr, sizeof(params->p_cscf_prim_addr), temp, max_ipv6_size);
    #####:  797:        prefer_ipv6(params->p_cscf_prim_addr, sizeof(params->p_cscf_prim_addr), temp, max_ipv6_size);
    #####:  798:        ipv6_and_subnetmask[0] = '\0';
    #####:  799:        temp[0] = '\0';
        -:  800:
    #####:  801:        _at.read_string(ipv6_and_subnetmask, ipv6_subnet_size);
    #####:  802:        separate_ip_addresses(ipv6_and_subnetmask, params->p_cscf_sec_addr, sizeof(params->p_cscf_sec_addr), temp, max_ipv6_size);
    #####:  803:        prefer_ipv6(params->p_cscf_sec_addr, sizeof(params->p_cscf_sec_addr), temp, max_ipv6_size);
        -:  804:
    #####:  805:        params->im_signalling_flag = _at.read_int();
    #####:  806:        params->lipa_indication = _at.read_int();
    #####:  807:        params->ipv4_mtu = _at.read_int();
    #####:  808:        params->wlan_offload = _at.read_int();
    #####:  809:        params->local_addr_ind = _at.read_int();
    #####:  810:        params->non_ip_mtu = _at.read_int();
    #####:  811:        params->serving_plmn_rate_control_value = _at.read_int();
        -:  812:    }
        1:  813:    _at.resp_stop();
        -:  814:
        1:  815:    free(temp);
        1:  816:    free(ipv6_and_subnetmask);
        -:  817:
        1:  818:    return _at.unlock_return_error();
        -:  819:}
        -:  820:
        2:  821:nsapi_error_t AT_CellularNetwork::get_extended_signal_quality(int &rxlev, int &ber, int &rscp, int &ecno, int &rsrq, int &rsrp)
        -:  822:{
        2:  823:    _at.lock();
        -:  824:
        2:  825:    _at.cmd_start("AT+CESQ");
        2:  826:    _at.cmd_stop();
        -:  827:
        2:  828:    _at.resp_start("+CESQ:");
        2:  829:    rxlev = _at.read_int();
        2:  830:    ber = _at.read_int();
        2:  831:    rscp = _at.read_int();
        2:  832:    ecno = _at.read_int();
        2:  833:    rsrq = _at.read_int();
        2:  834:    rsrp = _at.read_int();
        2:  835:    _at.resp_stop();
        2:  836:    if (rxlev < 0 || ber < 0 || rscp < 0 || ecno < 0 || rsrq < 0 || rsrp < 0) {
        1:  837:        _at.unlock();
        1:  838:        return NSAPI_ERROR_DEVICE_ERROR;
        -:  839:    }
        -:  840:
        1:  841:    return _at.unlock_return_error();
        -:  842:}
        -:  843:
        2:  844:nsapi_error_t AT_CellularNetwork::get_signal_quality(int &rssi, int &ber)
        -:  845:{
        2:  846:    _at.lock();
        -:  847:
        2:  848:    _at.cmd_start("AT+CSQ");
        2:  849:    _at.cmd_stop();
        -:  850:
        2:  851:    _at.resp_start("+CSQ:");
        2:  852:    rssi = _at.read_int();
        2:  853:    ber = _at.read_int();
        2:  854:    _at.resp_stop();
        2:  855:    if (rssi < 0 || ber < 0) {
        1:  856:        _at.unlock();
        1:  857:        return NSAPI_ERROR_DEVICE_ERROR;
        -:  858:    }
        -:  859:
        1:  860:    return _at.unlock_return_error();
        -:  861:}
        -:  862:
        -:  863:/** Get the last 3GPP error code
        -:  864: *  @return see 3GPP TS 27.007 error codes
        -:  865: */
        1:  866:uint8_t AT_CellularNetwork::get_3gpp_error()
        -:  867:{
        1:  868:    return _at.get_3gpp_error();
        -:  869:}
        -:  870:
        -:  871:
        1:  872:nsapi_error_t AT_CellularNetwork::get_operator_params(int &format, operator_t &operator_params)
        -:  873:{
        1:  874:    _at.lock();
        -:  875:
        1:  876:    _at.cmd_start("AT+COPS?");
        1:  877:    _at.cmd_stop();
        -:  878:
        1:  879:    _at.resp_start("+COPS: ");
        1:  880:    _at.read_int(); //ignore mode
        1:  881:    format = _at.read_int();
        -:  882:
        1:  883:    if (_at.get_last_error() == NSAPI_ERROR_OK) {
        -:  884:
    #####:  885:        switch (format) {
        -:  886:            case 0:
    #####:  887:                _at.read_string(operator_params.op_long, 16+9);
    #####:  888:                break;
        -:  889:
        -:  890:            case 1:
    #####:  891:                _at.read_string(operator_params.op_short, 8+4);
    #####:  892:                break;
        -:  893:
        -:  894:            default:
    #####:  895:                _at.read_string(operator_params.op_num, 8+4);
    #####:  896:                break;
        -:  897:        }
        -:  898:
    #####:  899:        operator_params.op_rat = (operator_t::RadioAccessTechnology)_at.read_int();
        -:  900:    }
        -:  901:
        1:  902:    _at.resp_stop();
        -:  903:
        1:  904:    return _at.unlock_return_error();
        -:  905:}
