        -:    0:Source:../../../framework/AT/AT_CellularDevice.cpp
        -:    0:Graph:objs/AT_CellularDevice_unit/AT_CellularDevice.gcno
        -:    0:Data:objs/AT_CellularDevice_unit/AT_CellularDevice.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/*
        -:    2: * Copyright (c) 2017, Arm Limited and affiliates.
        -:    3: * SPDX-License-Identifier: Apache-2.0
        -:    4: *
        -:    5: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    6: * you may not use this file except in compliance with the License.
        -:    7: * You may obtain a copy of the License at
        -:    8: *
        -:    9: *     http://www.apache.org/licenses/LICENSE-2.0
        -:   10: *
        -:   11: * Unless required by applicable law or agreed to in writing, software
        -:   12: * distributed under the License is distributed on an "AS IS" BASIS,
        -:   13: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   14: * See the License for the specific language governing permissions and
        -:   15: * limitations under the License.
        -:   16: */
        -:   17:
        -:   18:#include "AT_CellularDevice.h"
        -:   19:
        -:   20:using namespace events;
        -:   21:using namespace mbed;
        -:   22:
        -:   23:#define DEFAULT_AT_TIMEOUT 1000 // at default timeout in milliseconds
        -:   24:
       10:   25:AT_CellularDevice::AT_CellularDevice(EventQueue &queue) :
       10:   26:    _atHandlers(0), _network(0), _sms(0), _sim(0), _power(0), _multiplexer(0), _information(0), _queue(queue), _default_timeout(DEFAULT_AT_TIMEOUT)
        -:   27:{
       10:   28:}
        -:   29:
       21:   30:AT_CellularDevice::~AT_CellularDevice()
        -:   31:{
       10:   32:    close_network();
       10:   33:    close_sms();
       10:   34:    close_power();
       10:   35:    close_sim();
       10:   36:    close_multiplexer();
       10:   37:    close_information();
        -:   38:
       10:   39:    ATHandler *atHandler = _atHandlers;
       26:   40:    while (atHandler) {
        8:   41:        ATHandler *old = atHandler;
        8:   42:        atHandler = atHandler->_nextATHandler;
        8:   43:        delete old;
        8:   44:        old = NULL;
        -:   45:    }
       11:   46:}
        -:   47:
        -:   48:// each parser is associated with one filehandle (that is UART or a MUX channel)
       18:   49:ATHandler* AT_CellularDevice::get_at_handler(FileHandle *fileHandle)
        -:   50:{
       18:   51:    if (!fileHandle) {
        6:   52:        return NULL;
        -:   53:    }
       12:   54:    ATHandler *atHandler = _atHandlers;
       18:   55:    while (atHandler) {
        5:   56:        if (atHandler->get_file_handle() == fileHandle) {
        2:   57:            atHandler->inc_ref_count();
        2:   58:            return atHandler;
        -:   59:        }
        3:   60:        atHandler = atHandler->_nextATHandler;
        -:   61:    }
        -:   62:
       10:   63:    atHandler = new ATHandler(fileHandle, _queue, _default_timeout);
       10:   64:    if (atHandler) {
       10:   65:        atHandler->_nextATHandler = _atHandlers;
       10:   66:        _atHandlers = atHandler;
        -:   67:    }
        -:   68:
       10:   69:    return atHandler;
        -:   70:}
        -:   71:
       12:   72:void AT_CellularDevice::release_at_handler(ATHandler* at_handler)
        -:   73:{
       12:   74:    if (!at_handler) {
        1:   75:        return;
        -:   76:    }
       11:   77:    at_handler->dec_ref_count();
       11:   78:    if (at_handler->get_ref_count() == 0) {
        -:   79:        // we can delete this at_handler
       11:   80:        ATHandler *atHandler = _atHandlers;
       11:   81:        ATHandler *prev = NULL;
       37:   82:        while (atHandler) {
       15:   83:            if (atHandler == at_handler) {
        2:   84:                if (prev == NULL) {
        1:   85:                    _atHandlers = _atHandlers->_nextATHandler;
        -:   86:                }
        -:   87:                else {
        1:   88:                    prev->_nextATHandler = atHandler->_nextATHandler;
        -:   89:                }
        2:   90:                delete atHandler;
        2:   91:                atHandler = NULL;
        2:   92:                break;
        -:   93:            } else {
       13:   94:                prev = atHandler;
       13:   95:                atHandler =atHandler->_nextATHandler;
        -:   96:            }
        -:   97:        }
        -:   98:    }
        -:   99:}
        -:  100:
        3:  101:CellularNetwork *AT_CellularDevice::open_network(FileHandle *fh)
        -:  102:{
        3:  103:    if (!_network) {
        3:  104:        ATHandler *atHandler = get_at_handler(fh);
        3:  105:        if (atHandler) {
        2:  106:            _network = new AT_CellularNetwork(*atHandler);
        2:  107:            if (!_network) {
    #####:  108:                release_at_handler(atHandler);
        -:  109:            }
        -:  110:        }
        -:  111:    }
        3:  112:    return _network;
        -:  113:}
        -:  114:
        3:  115:CellularSMS *AT_CellularDevice::open_sms(FileHandle *fh)
        -:  116:{
        3:  117:    if (!_sms) {
        3:  118:        ATHandler *atHandler = get_at_handler(fh);
        3:  119:        if (atHandler) {
        2:  120:            _sms = new AT_CellularSMS(*atHandler);
        2:  121:            if (!_sms) {
    #####:  122:                release_at_handler(atHandler);
        -:  123:            }
        -:  124:        }
        -:  125:    }
        3:  126:    return _sms;
        -:  127:}
        -:  128:
        3:  129:CellularSIM *AT_CellularDevice::open_sim(FileHandle *fh)
        -:  130:{
        3:  131:    if (!_sim) {
        3:  132:        ATHandler *atHandler = get_at_handler(fh);
        3:  133:        if (atHandler) {
        2:  134:            _sim = new AT_CellularSIM(*atHandler);
        2:  135:            if (!_sim) {
    #####:  136:                release_at_handler(atHandler);
        -:  137:            }
        -:  138:        }
        -:  139:    }
        3:  140:    return _sim;
        -:  141:}
        -:  142:
        3:  143:CellularPower *AT_CellularDevice::open_power(FileHandle *fh)
        -:  144:{
        3:  145:    if (!_power) {
        3:  146:        ATHandler *atHandler = get_at_handler(fh);
        3:  147:        if (atHandler) {
        2:  148:            _power = new AT_CellularPower(*atHandler);
        2:  149:            if (!_power) {
    #####:  150:                release_at_handler(atHandler);
        -:  151:            }
        -:  152:        }
        -:  153:    }
        3:  154:    return _power;
        -:  155:}
        -:  156:
        2:  157:CellularMultiplexer *AT_CellularDevice::open_multiplexer(FileHandle *fh)
        -:  158:{
        2:  159:    if (!_multiplexer) {
        2:  160:        ATHandler *atHandler = get_at_handler(fh);
        2:  161:        if (atHandler) {
        1:  162:            _multiplexer = new AT_CellularMultiplexer(*atHandler);
        1:  163:            if (!_multiplexer) {
    #####:  164:                release_at_handler(atHandler);
        -:  165:            }
        -:  166:        }
        -:  167:    }
        -:  168:
        2:  169:    return _multiplexer;
        -:  170:}
        -:  171:
        4:  172:CellularInformation *AT_CellularDevice::open_information(FileHandle *fh)
        -:  173:{
        4:  174:    if (!_information) {
        4:  175:        ATHandler *atHandler = get_at_handler(fh);
        4:  176:        if (atHandler) {
        3:  177:            _information = new AT_CellularInformation(*atHandler);
        3:  178:            if (!_information) {
    #####:  179:                release_at_handler(atHandler);
        -:  180:            }
        -:  181:        }
        -:  182:    }
        4:  183:    return _information;
        -:  184:}
        -:  185:
       10:  186:void AT_CellularDevice::close_network()
        -:  187:{
       10:  188:    if (_network) {
        2:  189:        release_at_handler(&_network->get_at_handler());
        2:  190:        delete _network;
        2:  191:        _network = NULL;
        -:  192:    }
       10:  193:}
        -:  194:
       10:  195:void AT_CellularDevice::close_sms()
        -:  196:{
       10:  197:    if (_sms) {
        2:  198:        release_at_handler(&_sms->get_at_handler());
        2:  199:        delete _sms;
        2:  200:        _sms = NULL;
        -:  201:    }
       10:  202:}
       10:  203:void AT_CellularDevice::close_power()
        -:  204:{
       10:  205:    if (_power) {
        2:  206:        release_at_handler(&_power->get_at_handler());
        2:  207:        delete _power;
        2:  208:        _power = NULL;
        -:  209:    }
       10:  210:}
        -:  211:
       10:  212:void AT_CellularDevice::close_sim()
        -:  213:{
       10:  214:    if (_sim) {
        2:  215:        release_at_handler(&_sim->get_at_handler());
        2:  216:        delete _sim;
        2:  217:        _sim = NULL;
        -:  218:    }
       10:  219:}
        -:  220:
       10:  221:void AT_CellularDevice::close_multiplexer()
        -:  222:{
       10:  223:    if (_multiplexer) {
        1:  224:        release_at_handler(&_multiplexer->get_at_handler());
        1:  225:        delete _multiplexer;
        1:  226:        _multiplexer = NULL;
        -:  227:    }
       10:  228:}
        -:  229:
       12:  230:void AT_CellularDevice::close_information()
        -:  231:{
       12:  232:    if (_information) {
        3:  233:        release_at_handler(&_information->get_at_handler());
        3:  234:        delete _information;
        3:  235:        _information = NULL;
        -:  236:    }
       12:  237:}
        -:  238:
    #####:  239:void AT_CellularDevice::set_timeout(int timeout)
        -:  240:{
    #####:  241:    _default_timeout = timeout;
        -:  242:
    #####:  243:    ATHandler *atHandler = _atHandlers;
    #####:  244:    while (atHandler) {
    #####:  245:        atHandler->set_at_timeout(_default_timeout, true); // set as default timeout
    #####:  246:        atHandler = atHandler->_nextATHandler;
        -:  247:    }
    #####:  248:}
