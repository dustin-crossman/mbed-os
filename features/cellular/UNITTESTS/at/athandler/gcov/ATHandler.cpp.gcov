        -:    0:Source:../../../framework/AT/ATHandler.cpp
        -:    0:Graph:objs/ATHandler_unit/ATHandler.gcno
        -:    0:Data:objs/ATHandler_unit/ATHandler.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/*
        -:    2: * Copyright (c) 2017, Arm Limited and affiliates.
        -:    3: * SPDX-License-Identifier: Apache-2.0
        -:    4: *
        -:    5: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    6: * you may not use this file except in compliance with the License.
        -:    7: * You may obtain a copy of the License at
        -:    8: *
        -:    9: *     http://www.apache.org/licenses/LICENSE-2.0
        -:   10: *
        -:   11: * Unless required by applicable law or agreed to in writing, software
        -:   12: * distributed under the License is distributed on an "AS IS" BASIS,
        -:   13: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   14: * See the License for the specific language governing permissions and
        -:   15: * limitations under the License.
        -:   16: */
        -:   17:
        -:   18:#include "ATHandler.h"
        -:   19:#include "mbed_poll.h"
        -:   20:#include "FileHandle.h"
        -:   21:#include "Timer.h"
        -:   22:#include "mbed_wait_api.h"
        -:   23:#include "mbed_debug.h"
        -:   24:#ifdef MBED_CONF_RTOS_PRESENT
        -:   25:#include "rtos/Thread.h"
        -:   26:#endif
        -:   27:
        -:   28:using namespace mbed;
        -:   29:using namespace events;
        -:   30:
        -:   31://#define MBED_TRACE_MAX_LEVEL TRACE_LEVEL_DEBUG
        -:   32:#include "CellularLog.h"
        -:   33:
        -:   34:// this is intentionally TRACE_LEVEL_INFO
        -:   35:#if MBED_TRACE_MAX_LEVEL <= TRACE_LEVEL_INFO
        -:   36:#define at_debug(format, ...) do { if (_debug_on) debug(format, ## __VA_ARGS__); } while (0)
        -:   37:#else
        -:   38:#define at_debug(...)
        -:   39:#endif
        -:   40:
        -:   41:const char *mbed::OK = "OK\r\n";
        -:   42:const uint8_t OK_LENGTH = 4;
        -:   43:const char *mbed::CRLF = "\r\n";
        -:   44:const uint8_t CRLF_LENGTH = 2;
        -:   45:const char *CME_ERROR = "+CME ERROR:";
        -:   46:const uint8_t CME_ERROR_LENGTH = 11;
        -:   47:const char *CMS_ERROR = "+CMS ERROR:";
        -:   48:const uint8_t CMS_ERROR_LENGTH = 11;
        -:   49:const char *ERROR_ = "ERROR\r\n";
        -:   50:const uint8_t ERROR_LENGTH = 7;
        -:   51:const uint8_t MAX_RESP_LENGTH = CMS_ERROR_LENGTH;
        -:   52:
        -:   53:static const uint8_t map_3gpp_errors[][2] =  {
        -:   54:    { 103, 3 },  { 106, 6 },  { 107, 7 },  { 108, 8 },  { 111, 11 }, { 112, 12 }, { 113, 13 }, { 114, 14 },
        -:   55:    { 115, 15 }, { 122, 22 }, { 125, 25 }, { 172, 95 }, { 173, 96 }, { 174, 97 }, { 175, 99 }, { 176, 111 },
        -:   56:    { 177, 8 },  { 126, 26 }, { 127, 27 }, { 128, 28 }, { 129, 29 }, { 130, 30 }, { 131, 31 }, { 132, 32 },
        -:   57:    { 133, 33 }, { 134, 34 }, { 140, 40 }, { 141, 41 }, { 142, 42 }, { 143, 43 }, { 144, 44 }, { 145, 45 },
        -:   58:    { 146, 46 }, { 178, 65 }, { 179, 66 }, { 180, 48 }, { 181, 83 }, { 171, 49 },
        -:   59:};
        -:   60:
       38:   61:ATHandler::ATHandler(FileHandle *fh, EventQueue &queue, int timeout, const char *output_delimiter) :
        -:   62:    _nextATHandler(0),
        -:   63:    _fileHandle(fh),
        -:   64:    _queue(queue),
        -:   65:    _last_err(NSAPI_ERROR_OK),
        -:   66:    _last_3gpp_error(0),
        -:   67:    _oob_string_max_length(0),
        -:   68:    _oobs(NULL),
        -:   69:    _at_timeout(timeout),
        -:   70:    _previous_at_timeout(timeout),
        -:   71:    _fh_sigio_set(false),
        -:   72:    _processing(false),
        -:   73:    _ref_count(1),
        -:   74:    _stop_tag(NULL),
        -:   75:    _delimiter(','),
        -:   76:    _prefix_matched(false),
        -:   77:    _urc_matched(false),
        -:   78:    _error_found(false),
        -:   79:    _max_resp_length(MAX_RESP_LENGTH),
        -:   80:#if MBED_TRACE_MAX_LEVEL == TRACE_LEVEL_DEBUG
        -:   81:    _debug_on(true),
        -:   82:#else
        -:   83:    _debug_on(false),
        -:   84:#endif
       38:   85:    _cmd_start(false)
        -:   86:{
        -:   87:    //enable_debug(true);
        -:   88:
       38:   89:    clear_error();
        -:   90:
       38:   91:    if (output_delimiter) {
       37:   92:        _output_delimiter_length = strlen(output_delimiter);
       37:   93:        _output_delimiter = new char[_output_delimiter_length];
       74:   94:        for (unsigned i=0; i<_output_delimiter_length; i++) {
       37:   95:            _output_delimiter[i] = output_delimiter[i];
        -:   96:        }
        -:   97:    } else {
        1:   98:        _output_delimiter_length = 0;
        1:   99:        _output_delimiter = NULL;
        -:  100:    }
        -:  101:
       38:  102:    reset_buffer();
       38:  103:    memset(_info_resp_prefix, 0, sizeof(_info_resp_prefix));
        -:  104:
       38:  105:    _current_scope = NotSet;
       38:  106:    set_tag(&_resp_stop, OK);
       38:  107:    set_tag(&_info_stop, CRLF);
       38:  108:    set_tag(&_elem_stop, ")");
        -:  109:
       38:  110:    _fileHandle->set_blocking(false);
        -:  111:
       38:  112:    set_filehandle_sigio();
       38:  113:}
        -:  114:
        2:  115:void ATHandler::enable_debug(bool enable)
        -:  116:{
        2:  117:    _debug_on = enable;
        2:  118:}
        -:  119:
       79:  120:ATHandler::~ATHandler()
        -:  121:{
       44:  122:    while (_oobs) {
        3:  123:        struct oob_t *oob = _oobs;
        3:  124:        _oobs = oob->next;
        3:  125:        delete oob;
        -:  126:    }
       38:  127:    if (_output_delimiter) {
       37:  128:        delete [] _output_delimiter;
        -:  129:    }
       38:  130:}
        -:  131:
        3:  132:void ATHandler::inc_ref_count()
        -:  133:{
        3:  134:    _ref_count++;
        3:  135:}
        -:  136:
        3:  137:void ATHandler::dec_ref_count()
        -:  138:{
        3:  139:    _ref_count--;
        3:  140:}
        -:  141:
        4:  142:int ATHandler::get_ref_count()
        -:  143:{
        4:  144:    return _ref_count;
        -:  145:}
        -:  146:
        1:  147:FileHandle *ATHandler::get_file_handle()
        -:  148:{
        1:  149:    return _fileHandle;
        -:  150:}
        -:  151:
        1:  152:void ATHandler::set_file_handle(FileHandle *fh)
        -:  153:{
        1:  154:    _fileHandle = fh;
        1:  155:}
        -:  156:
        3:  157:void ATHandler::set_urc_handler(const char *prefix, mbed::Callback<void()> callback)
        -:  158:{
        3:  159:    struct oob_t *oob = new struct oob_t;
        3:  160:    oob->matching_to_received = true;
        3:  161:    size_t prefix_len = strlen(prefix);
        3:  162:    if (prefix_len > _oob_string_max_length) {
        3:  163:        _oob_string_max_length = prefix_len;
        3:  164:        if (_oob_string_max_length > _max_resp_length) {
        1:  165:            _max_resp_length = _oob_string_max_length;
        -:  166:        }
        -:  167:    }
        3:  168:    oob->prefix = prefix;
        3:  169:    oob->cb = callback;
        3:  170:    oob->next = _oobs;
        3:  171:    _oobs = oob;
        3:  172:}
        -:  173:
       38:  174:void ATHandler::event()
        -:  175:{
        -:  176:    // _processing must be set before filehandle write/read to avoid repetitive sigio events
       38:  177:    if (!_processing) {
       38:  178:        _processing = true;
       38:  179:        (void) _queue.call(Callback<void(void)>(this, &ATHandler::process_oob));
        -:  180:    }
       38:  181:}
        -:  182:
        6:  183:void ATHandler::lock()
        -:  184:{
        -:  185:#ifdef AT_HANDLER_MUTEX
        6:  186:    _fileHandleMutex.lock();
        -:  187:#endif
        6:  188:    _processing = true;
        6:  189:    clear_error();
        6:  190:}
        -:  191:
        7:  192:void ATHandler::unlock()
        -:  193:{
        7:  194:    _processing = false;
        -:  195:#ifdef AT_HANDLER_MUTEX
        7:  196:    _fileHandleMutex.unlock();
        -:  197:#endif
        7:  198:    if (_fileHandle->readable() || (_recv_pos < _recv_len)) {
        1:  199:        (void) _queue.call(Callback<void(void)>(this, &ATHandler::process_oob));
        -:  200:    }
        7:  201:}
        -:  202:
        1:  203:nsapi_error_t ATHandler::unlock_return_error()
        -:  204:{
        1:  205:    nsapi_error_t err = _last_err;
        1:  206:    unlock();
        1:  207:    return err;
        -:  208:}
        -:  209:
        4:  210:void ATHandler::set_at_timeout(uint32_t timeout_milliseconds, bool default_timeout)
        -:  211:{
        4:  212:    if (default_timeout) {
        2:  213:        _previous_at_timeout = timeout_milliseconds;
        2:  214:        _at_timeout = timeout_milliseconds;
        2:  215:    } else if (timeout_milliseconds != _at_timeout) {
        2:  216:        _previous_at_timeout = _at_timeout;
        2:  217:        _at_timeout = timeout_milliseconds;
        -:  218:    }
        4:  219:}
        -:  220:
        1:  221:void ATHandler::restore_at_timeout()
        -:  222:{
        1:  223:    if (_previous_at_timeout != _at_timeout) {
        1:  224:        _at_timeout =_previous_at_timeout;
        -:  225:    }
        1:  226:}
        -:  227:
        5:  228:void ATHandler::process_oob()
        -:  229:{
        5:  230:    lock();
        -:  231:    log_debug("process_oob %d", (_fileHandle->readable() || (_recv_pos < _recv_len)));
        5:  232:    if (_fileHandle->readable() || (_recv_pos < _recv_len)) {
        5:  233:        _current_scope = NotSet;
       10:  234:        Timer timer;
        5:  235:        timer.start();
        4:  236:        do {
        5:  237:            if (match_urc()) {
        2:  238:                if (_fileHandle->readable() || (_recv_pos < _recv_len)) {
        1:  239:                    continue;
        -:  240:                }
        1:  241:                break;
        -:  242:            }
        -:  243:            // If no match found, look for CRLF and consume everything up to CRLF
        3:  244:            if (mem_str(_recv_buff, sizeof(_recv_buff), CRLF, CRLF_LENGTH)) {
        1:  245:                consume_to_tag(CRLF, true);
        -:  246:            } else {
        2:  247:                if (_fileHandle->readable()) {
        1:  248:                    fill_buffer();
        -:  249:                } else {
        -:  250:#ifdef MBED_CONF_RTOS_PRESENT
        -:  251:                    rtos::Thread::yield();
        -:  252:#endif
        -:  253:                }
        -:  254:
        -:  255:            }
        4:  256:        } while (timer.read_ms() < 100);
        -:  257:    }
        -:  258:    log_debug("process_oob exit");
        -:  259:
        5:  260:    flush(); // consume anything that could not be handled
        -:  261:
        5:  262:    unlock();
        5:  263:}
        -:  264:
        -:  265:// oob match settings
        -:  266://DEAD CODE?
    #####:  267:void ATHandler::set_oobs_matching_param(bool is_it_a_match_or_not)
        -:  268:{
    #####:  269:    for (struct oob_t *oob = _oobs; oob; oob = oob->next) {
    #####:  270:        oob->matching_to_received = is_it_a_match_or_not;
        -:  271:    }
    #####:  272:}
        -:  273:
       39:  274:void ATHandler::set_filehandle_sigio()
        -:  275:{
       39:  276:    if (_fh_sigio_set) {
        1:  277:        return;
        -:  278:    }
       38:  279:    _fileHandle->sigio(mbed::Callback<void()>(this, &ATHandler::event));
       38:  280:    _fh_sigio_set = true;
        -:  281:}
        -:  282:
      101:  283:void ATHandler::reset_buffer()
        -:  284:{
        -:  285:    log_debug("%s", __func__);
      101:  286:    memset(_recv_buff, 0, sizeof(_recv_buff));
      101:  287:    _recv_pos = 0; _recv_len = 0;
      101:  288:}
        -:  289:
      196:  290:void ATHandler::rewind_buffer()
        -:  291:{
        -:  292:    log_debug("%s", __func__);
      196:  293:    if (_recv_pos > 0 && _recv_len >= _recv_pos) {
        5:  294:        _recv_len -= _recv_pos;
        -:  295:        // move what is not read to beginning of buffer
        5:  296:        memmove(_recv_buff, _recv_buff + _recv_pos, _recv_len);
        5:  297:        _recv_pos = 0;
        -:  298:        // reset rest of buffer
        5:  299:        memset(_recv_buff + _recv_len, 0, sizeof(_recv_buff) - _recv_len);
        -:  300:    }
      196:  301:}
        -:  302:
        -:  303:// we are always expecting to receive something so there is wait timeout
       63:  304:void ATHandler::fill_buffer()
        -:  305:{
        -:  306:    log_debug("%s", __func__);
        -:  307:    // Reset buffer when full
       63:  308:    if (sizeof(_recv_buff) == _recv_len) {
    #####:  309:        reset_buffer();
        -:  310:    }
        -:  311:
       90:  312:    Timer timer;
       63:  313:    timer.start();
       27:  314:    do {
       63:  315:       ssize_t len = _fileHandle->read(_recv_buff + _recv_len, sizeof(_recv_buff) - _recv_len);
       63:  316:        if (len > 0) {
       36:  317:            _recv_len += len;
       36:  318:           at_debug("\n----------readable----------: %d\n", _recv_len);
      420:  319:           for (size_t i = _recv_pos; i < _recv_len; i++) {
      384:  320:               at_debug("%c", _recv_buff[i]);
        -:  321:           }
       36:  322:           at_debug("\n----------readable----------\n");
       36:  323:           return;
        -:  324:       }
        -:  325:#ifdef MBED_CONF_RTOS_PRESENT
        -:  326:        rtos::Thread::yield();
        -:  327:#endif
       27:  328:    } while (timer.read_ms() < _at_timeout);
        -:  329:
       27:  330:    set_error(NSAPI_ERROR_DEVICE_ERROR);
       27:  331:    log_error("AT TIMEOUT, scope: %d timeout: %d", _current_scope, _at_timeout);
        -:  332:}
        -:  333:
      267:  334:int16_t ATHandler::get_char()
        -:  335:{
      267:  336:    if (_recv_pos == _recv_len) {
        -:  337:        log_debug("%s", __func__);
       30:  338:        reset_buffer(); // try to read as much as possible
       30:  339:        fill_buffer();
       30:  340:        if (get_last_error()) {
        -:  341:            log_debug("%s: -1", __func__);
       21:  342:            return -1; // timeout to read
        -:  343:        }
        -:  344:    }
        -:  345:
        -:  346:    log_debug("%s: %c", __func__, _recv_buff[_recv_pos]);
        -:  347:
      246:  348:    return _recv_buff[_recv_pos++];
        -:  349:}
        -:  350:
        5:  351:void ATHandler::skip_param(uint32_t count)
        -:  352:{
        -:  353:    log_debug("%s", __func__);
        5:  354:    if (_last_err || !_stop_tag || _stop_tag->found) {
        1:  355:        return;
        -:  356:    }
        -:  357:
        6:  358:    for (uint32_t i=0; (i < count && !_stop_tag->found); i++) {
        4:  359:        size_t match_pos = 0;
       54:  360:        while (true) {
       58:  361:            int16_t c = get_char();
       58:  362:            if (c == -1) {
        2:  363:                set_error(NSAPI_ERROR_DEVICE_ERROR);
        2:  364:                return;
       56:  365:            } else if (c == _delimiter) {
        1:  366:                break;
       55:  367:            } else if (_stop_tag->len && c == _stop_tag->tag[match_pos]) {
        6:  368:                match_pos++;
       11:  369:                if (match_pos == _stop_tag->len) {
        1:  370:                    _stop_tag->found = true;
        1:  371:                    break;
        -:  372:                }
       49:  373:            } else if (match_pos) {
        1:  374:                match_pos = 0;
        -:  375:            }
        -:  376:        }
        -:  377:    }
        2:  378:    return;
        -:  379:}
        -:  380:
        3:  381:void ATHandler::skip_param(ssize_t len, uint32_t count)
        -:  382:{
        -:  383:    log_debug("%s", __func__);
        3:  384:    if (_last_err || !_stop_tag || _stop_tag->found) {
        1:  385:        return;
        -:  386:    }
        -:  387:
        5:  388:    for (uint32_t i=0; i < count; i++) {
        4:  389:        ssize_t read_len = 0;
       56:  390:        while (read_len < len) {
       27:  391:            int16_t c = get_char();
       27:  392:            if (c == -1) {
        1:  393:                set_error(NSAPI_ERROR_DEVICE_ERROR);
        1:  394:                return;
        -:  395:            }
       26:  396:            read_len++;
        -:  397:        }
        -:  398:    }
        1:  399:    return;
        -:  400:}
        -:  401:
        9:  402:ssize_t ATHandler::read_bytes(uint8_t *buf, size_t len)
        -:  403:{
        -:  404:    log_debug("%s", __func__);
        9:  405:    if (_last_err) {
        1:  406:        return -1;
        -:  407:    }
        -:  408:
        8:  409:    size_t read_len = 0;
       54:  410:    for (; read_len<len; read_len++) {
       24:  411:        int16_t c = get_char();
       24:  412:        if (c == -1) {
        1:  413:            set_error(NSAPI_ERROR_DEVICE_ERROR);
        1:  414:            return -1;
        -:  415:        }
       23:  416:        buf[read_len] = c;
        -:  417:    }
        7:  418:    return read_len;
        -:  419:}
        -:  420:
       11:  421:ssize_t ATHandler::read_string(char *buf, size_t size, bool read_even_stop_tag)
        -:  422:{
        -:  423:    log_debug("%s", __func__);
       11:  424:    at_debug("\n----------buff:----------\n");
       61:  425:    for (size_t i = _recv_pos; i < _recv_len; i++) {
       50:  426:        at_debug("%c", _recv_buff[i]);
        -:  427:    }
       11:  428:    at_debug("\n----------buff----------\n");
        -:  429:
       11:  430:    if (_last_err || !_stop_tag || (_stop_tag->found && read_even_stop_tag == false)) {
        1:  431:        return -1;
        -:  432:    }
        -:  433:
       10:  434:    uint8_t *pbuf = (uint8_t*)buf;
        -:  435:
       10:  436:    size_t len = 0;
       10:  437:    size_t match_pos = 0;
        -:  438:
       10:  439:    consume_char('\"');
        -:  440:
       60:  441:    for (; len<(size + match_pos); len++) {
       34:  442:        int16_t c = get_char();
       34:  443:        if (c == -1) {
        5:  444:            pbuf[len] = '\0';
        5:  445:            set_error(NSAPI_ERROR_DEVICE_ERROR);
        5:  446:            return -1;
       29:  447:        } else if (c == _delimiter) {
        3:  448:            pbuf[len] = '\0';
        3:  449:            break;
       26:  450:        } else if (c == '\"') {
        1:  451:            match_pos = 0;
        1:  452:            len--;
        1:  453:            continue;
       25:  454:        } else if (_stop_tag->len && c == _stop_tag->tag[match_pos]) {
        5:  455:            match_pos++;
        9:  456:            if (match_pos == _stop_tag->len) {
        1:  457:                _stop_tag->found = true;
        -:  458:                // remove tag from string if it was matched
        1:  459:                len -= (_stop_tag->len - 1);
        1:  460:                pbuf[len] = '\0';
        1:  461:                break;
        -:  462:            }
       20:  463:        } else if (match_pos) {
        1:  464:            match_pos = 0;
        -:  465:        }
        -:  466:
       24:  467:        pbuf[len] = c;
        -:  468:    }
        -:  469:
        -:  470:    // Do we need _stop_found set after reading by size -> is _stop_tag_by_len needed or not?
        5:  471:    return len;
        -:  472:}
        -:  473:
        7:  474:int32_t ATHandler::read_int()
        -:  475:{
        -:  476:    log_debug("%s", __func__);
        -:  477:
        7:  478:     if (_last_err || !_stop_tag || _stop_tag->found) {
        1:  479:         return -1;
        -:  480:     }
        -:  481:
        6:  482:    char buff[BUFF_SIZE] = {0};
        -:  483:    char *first_no_digit;
        -:  484:
        6:  485:    if (read_string(buff, (size_t)sizeof(buff)) == 0) {
        1:  486:        return -1;
        -:  487:    }
        -:  488:
        5:  489:    return std::strtol(buff, &first_no_digit, 10);
        -:  490:}
        -:  491:
        1:  492:void ATHandler::set_delimiter(char delimiter)
        -:  493:{
        1:  494:    _delimiter = delimiter;
        1:  495:}
        -:  496:
      118:  497:void ATHandler::set_tag(tag_t* tag_dst, const char *tag_seq)
        -:  498:{
      118:  499:    if (tag_seq) {
      118:  500:        size_t tag_len = strlen(tag_seq);
      118:  501:        set_string(tag_dst->tag, tag_seq, tag_len);
      118:  502:        tag_dst->len = tag_len;
      118:  503:        tag_dst->found = false;
        -:  504:    } else {
    #####:  505:        _stop_tag = NULL;
        -:  506:    }
      118:  507:}
        -:  508:
        2:  509:void ATHandler::set_stop_tag(const char *stop_tag_seq)
        -:  510:{
        2:  511:    if (_last_err || !_stop_tag) {
        1:  512:        return;
        -:  513:    }
        -:  514:
        1:  515:    set_tag(_stop_tag, stop_tag_seq);
        -:  516:}
        -:  517:
       50:  518:void ATHandler::set_scope(ScopeType scope_type, const char* stop_tag)
        -:  519:{
        -:  520:    log_debug("%s: %d", __func__, scope_type);
       50:  521:    if (_current_scope != scope_type) {
       34:  522:        _current_scope = scope_type;
       34:  523:        switch (_current_scope) {
        -:  524:        case RespType:
       16:  525:            _stop_tag = &_resp_stop;
       16:  526:            _stop_tag->found = false;
       16:  527:            break;
        -:  528:        case InfoType:
       15:  529:            _stop_tag = &_info_stop;
       15:  530:            _stop_tag->found = false;
       15:  531:            consume_char(' ');
       15:  532:            break;
        -:  533:        case ElemType:
        2:  534:            _stop_tag = &_elem_stop;
        2:  535:            _stop_tag->found = false;
        2:  536:            break;
        -:  537:        case NotSet:
        1:  538:            _stop_tag = NULL;
        1:  539:            return;
        -:  540:        default:
    #####:  541:            break;
        -:  542:        }
        -:  543:    }
        -:  544:
        -:  545:    //CURRENTLY DEAD CODE
       49:  546:    if (stop_tag) {
    #####:  547:        set_stop_tag(stop_tag);
        -:  548:    }
        -:  549:}
        -:  550:
        -:  551:// should match from recv_pos?
      150:  552:bool ATHandler::match(const char* str, size_t size)
        -:  553:{
        -:  554:    log_debug("%s: %s", __func__, str);
      150:  555:    rewind_buffer();
        -:  556:
      150:  557:    if ((_recv_len - _recv_pos) < size) {
       58:  558:        return false;
        -:  559:    }
        -:  560:
       92:  561:    if (str && memcmp(_recv_buff + _recv_pos, str, size) == 0) {
        -:  562:        // consume matching part
       15:  563:        _recv_pos += size;
       15:  564:        return true;
        -:  565:    }
       77:  566:    return false;
        -:  567:}
        -:  568:
       20:  569:bool ATHandler::match_urc()
        -:  570:{
        -:  571:    log_debug("%s", __func__);
       20:  572:    rewind_buffer();
       20:  573:    size_t prefix_len = 0;
       23:  574:    for (struct oob_t *oob = _oobs; oob; oob = oob->next) {
        6:  575:        prefix_len = strlen(oob->prefix);
        6:  576:        if (_recv_len >= prefix_len) {
        4:  577:            if (match(oob->prefix, prefix_len)) {
        -:  578:                log_debug("URC!");
        3:  579:                set_scope(InfoType);
        3:  580:                if(oob->cb){
        2:  581:                    oob->cb();
        -:  582:                }
        3:  583:                information_response_stop();
        3:  584:                return true;
        -:  585:            }
        -:  586:        }
        -:  587:    }
       17:  588:    return false;
        -:  589:}
        -:  590:
       28:  591:bool ATHandler::match_error()
        -:  592:{
        -:  593:    log_debug("%s", __func__);
        -:  594:
       28:  595:    if (match(CME_ERROR, CME_ERROR_LENGTH)) {
        3:  596:        at_error(true, DeviceErrorTypeErrorCME);
        3:  597:        return true;
       25:  598:    } else if (match(CMS_ERROR, CMS_ERROR_LENGTH)) {
        1:  599:        at_error(true, DeviceErrorTypeErrorCMS);
        1:  600:        return true;
       24:  601:    } else if (match(ERROR_, ERROR_LENGTH)) {
        1:  602:        at_error(false, DeviceErrorTypeNoError);
        1:  603:        return true;
        -:  604:    }
        -:  605:
       23:  606:    return false;
        -:  607:}
        -:  608:
       79:  609:void ATHandler::clear_error()
        -:  610:{
       79:  611:    _last_err = NSAPI_ERROR_OK;
       79:  612:    _last_at_err.errCode = 0;
       79:  613:    _last_at_err.errType = DeviceErrorTypeNoError;
       79:  614:    _last_3gpp_error = 0;
       79:  615:}
        -:  616:
       73:  617:nsapi_error_t ATHandler::get_last_error() const
        -:  618:{
       73:  619:    return _last_err;
        -:  620:}
        -:  621:
        1:  622:device_err_t ATHandler::get_last_device_error() const
        -:  623:{
        1:  624:    return _last_at_err;
        -:  625:}
        -:  626:
       53:  627:void ATHandler::set_error(nsapi_error_t err)
        -:  628:{
       53:  629:    if (_last_err == NSAPI_ERROR_OK) {
       29:  630:        _last_err = err;
        -:  631:    }
        -:  632:
       53:  633:    if (_last_err != err) {
        -:  634:        log_warn("AT error code changed from %d to %d!", _last_err, err);
        -:  635:    }
       53:  636:}
        -:  637:
        1:  638:uint8_t ATHandler::get_3gpp_error()
        -:  639:{
        1:  640:    return _last_3gpp_error;
        -:  641:}
        -:  642:
        4:  643:void ATHandler::set_3gpp_error(uint8_t err, DeviceErrorType error_type)
        -:  644:{
        4:  645:    if (_last_3gpp_error) { // don't overwrite likely root cause error
    #####:  646:        return;
        -:  647:    }
        -:  648:
        4:  649:    if (error_type == DeviceErrorTypeErrorCMS && err < 128) {
        -:  650:        // CMS errors 0-127 maps straight to 3GPP errors
        1:  651:        _last_3gpp_error = err;
        -:  652:    } else {
       12:  653:        for (size_t i=0; i<sizeof(map_3gpp_errors)/sizeof(map_3gpp_errors[0]); i++) {
       12:  654:            if (map_3gpp_errors[i][0] == err) {
        3:  655:                _last_3gpp_error = map_3gpp_errors[i][1];
        -:  656:                log_debug("AT3GPP error code %d", get_3gpp_error());
        3:  657:                break;
        -:  658:            }
        -:  659:        }
        -:  660:    }
        -:  661:}
        -:  662:
        5:  663:void ATHandler::at_error(bool error_code_expected, DeviceErrorType error_type)
        -:  664:{
        5:  665:    int32_t err = -1;
        -:  666:
        5:  667:    if (error_code_expected && (error_type == DeviceErrorTypeErrorCMS || error_type == DeviceErrorTypeErrorCME)) {
        4:  668:        set_scope(InfoType);
        4:  669:        err = read_int();
        -:  670:
        4:  671:        if (err != -1) {
        4:  672:            set_3gpp_error(err, error_type);
        4:  673:            _last_at_err.errCode = err;
        4:  674:            _last_at_err.errType = error_type;
        -:  675:            log_debug("ATHandler ERROR: %d", err);
        -:  676:        } else {
        -:  677:            log_debug("ATHandler ERROR reading failed");
        -:  678:        }
        -:  679:    }
        -:  680:
        5:  681:    _last_err = NSAPI_ERROR_DEVICE_ERROR;
        5:  682:}
        -:  683:
       29:  684:void ATHandler::resp(const char *prefix, bool check_urc)
        -:  685:{
        -:  686:    log_debug("%s: %s", __func__, prefix);
        -:  687:
       29:  688:    at_debug("\n----------buff:----------\n");
      261:  689:    for (size_t i = _recv_pos; i < _recv_len; i++) {
      232:  690:        at_debug("%c", _recv_buff[i]);
        -:  691:    }
       29:  692:    at_debug("\n----------buff----------\n");
        -:  693:
       29:  694:    _prefix_matched = false;
       29:  695:    _urc_matched = false;
       29:  696:    _error_found = false;
        -:  697:
       41:  698:    while (!get_last_error()) {
        -:  699:
       29:  700:        match(CRLF, CRLF_LENGTH);
        -:  701:
       29:  702:        if (match(OK, OK_LENGTH)) {
        1:  703:            set_scope(RespType);
        1:  704:            _stop_tag->found = true;
        1:  705:            return;
        -:  706:        }
        -:  707:
       28:  708:        if(match_error()) {
        5:  709:            _error_found = true;
        5:  710:            return;
        -:  711:        }
        -:  712:
       23:  713:        if (prefix && match(prefix, strlen(prefix))) {
        6:  714:            _prefix_matched = true;
        6:  715:            return;
        -:  716:        }
        -:  717:
       17:  718:        if (check_urc && match_urc()) {
        1:  719:            _urc_matched = true;
        -:  720:        }
        -:  721:
        -:  722:        // If no match found, look for CRLF and consume everything up to and including CRLF
       17:  723:        if (mem_str(_recv_buff, sizeof(_recv_buff), CRLF, CRLF_LENGTH)) {
        -:  724:            // If no prefix, return on CRLF - means data to read
        7:  725:            if (!prefix) {
        6:  726:                return;
        -:  727:            }
        1:  728:            consume_to_tag(CRLF, true);
        -:  729:        } else {
        -:  730:            // If no prefix, no CRLF and no more chance to match for OK, ERROR or URC(since max resp length is already in buffer)
        -:  731:            // return so data could be read
       10:  732:            if (!prefix && ((_recv_len-_recv_pos) >= _max_resp_length)) {
        5:  733:                return;
        -:  734:            }
        5:  735:            fill_buffer();
        -:  736:        }
        -:  737:    }
        -:  738:
        6:  739:    return;
        -:  740:    // something went wrong so application need to recover and retry
        -:  741:}
        -:  742:
       28:  743:void ATHandler::resp_start(const char *prefix, bool stop)
        -:  744:{
        -:  745:    log_debug("%s: %s", __func__, prefix);
        -:  746:
       28:  747:    if (_last_err) {
        2:  748:        return;
        -:  749:    }
        -:  750:
        -:  751:    // Try get as much data as possible
       26:  752:    rewind_buffer();
       26:  753:    fill_buffer();
        -:  754:
       26:  755:    if (prefix) {
        7:  756:        if ((strlen(prefix) < sizeof(_info_resp_prefix))) {
        6:  757:            strcpy(_info_resp_prefix, prefix);
        -:  758:        } else {
        1:  759:            MBED_ASSERT(0);
        -:  760:        }
        -:  761:    }
        -:  762:
       26:  763:    set_scope(RespType);
        -:  764:
       26:  765:    resp(prefix, true);
        -:  766:
       26:  767:    if (!stop && prefix && _prefix_matched) {
        4:  768:        set_scope(InfoType);
        -:  769:    }
        -:  770:}
        -:  771:
        -:  772:// check urc because of error as urc
        5:  773:bool ATHandler::info_resp()
        -:  774:{
        -:  775:    log_debug("%s", __func__);
        5:  776:    if (_last_err || _resp_stop.found) {
        1:  777:        return false;
        -:  778:    }
        -:  779:
        4:  780:    if (_prefix_matched) {
        1:  781:        _prefix_matched = false;
        1:  782:       return true;
        -:  783:    }
        -:  784:
        -:  785:    // If coming here after another info response was started(looping), stop the previous one.
        -:  786:    // Trying to handle stopping in this level instead of doing it in upper level.
        3:  787:    if (get_scope() == InfoType) {
        1:  788:        information_response_stop();
        -:  789:    }
        -:  790:
        3:  791:    resp(_info_resp_prefix, false);
        -:  792:
        3:  793:    if (_prefix_matched) {
        2:  794:       set_scope(InfoType);
        2:  795:       _prefix_matched = false;
        2:  796:       return true;
        -:  797:    }
        -:  798:
        -:  799:    // On mismatch go to response scope
        1:  800:    set_scope(RespType);
        1:  801:    return false;
        -:  802:}
        -:  803:
        5:  804:bool ATHandler::info_elem(char start_tag)
        -:  805:{
        -:  806:    log_debug("%s: %c", __func__, start_tag);
        5:  807:    if (_last_err) {
        1:  808:        return false;
        -:  809:    }
        -:  810:
        -:  811:    // If coming here after another info response element was started(looping), stop the previous one.
        -:  812:    // Trying to handle stopping in this level instead of doing it in upper level.
        4:  813:    if (get_scope() == ElemType) {
        1:  814:        information_response_element_stop();
        -:  815:    }
        -:  816:
        4:  817:    consume_char(_delimiter);
        -:  818:
        4:  819:    if (consume_char(start_tag)) {
        3:  820:        _prefix_matched = true;
        3:  821:        set_scope(ElemType);
        3:  822:        return true;
        -:  823:    }
        -:  824:
        -:  825:    // On mismatch go to information response scope
        1:  826:    set_scope(InfoType);
        1:  827:    return false;
        -:  828:}
        -:  829:
       33:  830:bool ATHandler::consume_char(char ch)
        -:  831:{
        -:  832:    log_debug("%s: %c", __func__, ch);
       33:  833:    int16_t read_char = get_char();
        -:  834:    // If we read something else than ch, recover it
       33:  835:    if (read_char != ch && read_char != -1) {
       18:  836:        _recv_pos--;
       18:  837:        return false;
        -:  838:    }
       15:  839:    return true;
        -:  840:}
        -:  841:
       12:  842:bool ATHandler::consume_to_tag(const char *tag, bool consume_tag)
        -:  843:{
        -:  844:    log_debug("%s: %s", __func__, tag);
       12:  845:    size_t match_pos = 0;
        -:  846:
       79:  847:    while (true) {
       91:  848:        int16_t c = get_char();
       91:  849:        if (c == -1) {
        8:  850:            break;
       83:  851:        } else if (c == tag[match_pos]) {
       10:  852:            match_pos++;
       10:  853:            if (match_pos == strlen(tag)) {
        4:  854:                if (!consume_tag) {
    #####:  855:                    _recv_pos -= strlen(tag);
        -:  856:                }
        4:  857:                return true;
        -:  858:            }
       73:  859:        } else if (match_pos) {
    #####:  860:            match_pos = 0;
        -:  861:        }
        -:  862:    }
        8:  863:    log_error("consume_to_tag not found");
        8:  864:    return false;
        -:  865:}
        -:  866:
       13:  867:bool ATHandler::consume_to_stop_tag()
        -:  868:{
        -:  869:    log_debug("%s", __func__);
        -:  870:
       13:  871:    if (!_stop_tag || (_stop_tag && _stop_tag->found) || _error_found) {
        3:  872:        return true;
        -:  873:    }
        -:  874:
       10:  875:    if (consume_to_tag((const char*)_stop_tag->tag, true)) {
        2:  876:        return true;
        -:  877:    }
        -:  878:
        8:  879:    log_error("consume_to_stop_tag not found");
        8:  880:    set_error(NSAPI_ERROR_DEVICE_ERROR);
        8:  881:    return false;
        -:  882:}
        -:  883:
        -:  884:// consume by size needed?
        -:  885:
        3:  886:void ATHandler::resp_stop()
        -:  887:{
        -:  888:    // Do not return on error so that we can consume whatever there is in the buffer
        -:  889:    /*if (_last_err) {
        -:  890:        return;
        -:  891:    }*/
        -:  892:
        -:  893:    log_debug("%s", __func__);
        -:  894:
        3:  895:    if (_current_scope == ElemType) {
        1:  896:        information_response_element_stop();
        1:  897:        set_scope(InfoType);
        -:  898:    }
        -:  899:
        3:  900:    if (_current_scope == InfoType) {
        3:  901:        information_response_stop();
        -:  902:    }
        -:  903:
        -:  904:    // Go for response stop_tag
        3:  905:    if (consume_to_stop_tag()) {
        1:  906:        set_scope(NotSet);
        -:  907:    }
        -:  908:
        -:  909:    // Restore stop tag to OK
        3:  910:    set_tag(&_resp_stop, OK);
        -:  911:    // Reset info resp prefix
        3:  912:    memset(_info_resp_prefix, 0, sizeof(_info_resp_prefix));
        3:  913:}
        -:  914:
        7:  915:void ATHandler::information_response_stop()
        -:  916:{
        -:  917:    log_debug("%s", __func__);
        7:  918:    if (consume_to_stop_tag()) {
        2:  919:        set_scope(RespType);
        -:  920:    }
        7:  921:}
        -:  922:
        2:  923:void ATHandler::information_response_element_stop()
        -:  924:{
        -:  925:    log_debug("%s", __func__);
        2:  926:    if (consume_to_stop_tag()) {
        1:  927:        set_scope(InfoType);
        -:  928:    }
        2:  929:}
        -:  930:
        7:  931:ATHandler::ScopeType ATHandler::get_scope()
        -:  932:{
        7:  933:    return _current_scope;
        -:  934:}
        -:  935:
      118:  936:void ATHandler::set_string(char *dest, const char *src, size_t src_len)
        -:  937:{
      118:  938:    memcpy(dest, src, src_len);
      118:  939:    dest[src_len] = '\0';
      118:  940:}
        -:  941:
       20:  942:const char* ATHandler::mem_str(const char* dest, size_t dest_len, const char* src, size_t src_len)
        -:  943:{
      227:  944:   for(size_t i = 0; i < dest_len-src_len; ++i) {
      215:  945:      if(memcmp(dest+i, src, src_len) == 0) {
        8:  946:         return dest+i;
        -:  947:      }
        -:  948:   }
       12:  949:   return NULL;
        -:  950:}
        -:  951:
        4:  952:void ATHandler::cmd_start(const char* cmd)
        -:  953:{
        -:  954:    log_debug("AT> %s", cmd);
        -:  955:
        4:  956:    if (_last_err != NSAPI_ERROR_OK) {
        1:  957:        return;
        -:  958:    }
        -:  959:
        -:  960:    // write command
        5:  961:    for (size_t i = 0; i < strlen(cmd); i++) {
        3:  962:        if (write_char(cmd[i]) == false) {
        -:  963:            // writing failed ---> write_char have set the last error, return...
        1:  964:            return;
        -:  965:        }
        -:  966:    }
        -:  967:
        2:  968:    _cmd_start = true;
        -:  969:}
        -:  970:
        4:  971:void ATHandler::write_int(int32_t param)
        -:  972:{
        -:  973:    // do common checks before sending subparameter
        4:  974:    if (check_cmd_send() == false) {
        3:  975:        return;
        -:  976:    }
        -:  977:
        -:  978:    // write the integer subparameter
        1:  979:    const uint8_t str_len = 12;
        -:  980:    char number_string[str_len];
        1:  981:    int32_t result = std::snprintf(number_string, str_len, "%ld", param);
        1:  982:    if (result > 0 && result < str_len) {
        1:  983:        for (size_t i = 0; number_string[i]; i++) {
        1:  984:            if (write_char(number_string[i]) == false) {
        -:  985:                // writing failed ---> write_char have set the last error, break out
        1:  986:                break;
        -:  987:            }
        1:  988:        }
        -:  989:    } else {
        -:  990:        //This is DEAD CODE: longest value is "-2147483648" which is 11 characters long and passing int64 is not possible!
        -:  991:        // must have been 64-bit integer, not supported
    #####:  992:        set_error(NSAPI_ERROR_PARAMETER);
        -:  993:    }
        -:  994:}
        -:  995:
        5:  996:void ATHandler::write_string(const char* param, bool useQuotations)
        -:  997:{
        -:  998:    // do common checks before sending subparameter
        5:  999:    if (check_cmd_send() == false) {
        2: 1000:        return;
        -: 1001:    }
        -: 1002:
        -: 1003:    // we are writing string, surround it with quotes
        3: 1004:    if (useQuotations && write_char('\"') == false) {
        1: 1005:        return;
        -: 1006:    }
        -: 1007:
        7: 1008:    for (size_t i = 0; i < strlen(param); i++) {
        6: 1009:        if (write_char(param[i]) == false) {
        -: 1010:            // writing failed ---> write_char have set the last error, return
        1: 1011:            break;
        -: 1012:        }
        -: 1013:    }
        -: 1014:
        2: 1015:    if (useQuotations) {
        -: 1016:        // we are writing string, surround it with quotes
        2: 1017:        write_char('\"');
        -: 1018:    }
        -: 1019:}
        -: 1020:
        2: 1021:void ATHandler::cmd_stop()
        -: 1022:{
        2: 1023:    if (_last_err != NSAPI_ERROR_OK) {
        1: 1024:        return;
        -: 1025:    }
        -: 1026:     // Finish with CR
        1: 1027:    for (size_t i = 0; i < _output_delimiter_length; i++) {
        1: 1028:        if (write_char(_output_delimiter[i]) == false) {
        1: 1029:            break;
        -: 1030:        }
        -: 1031:    }
        -: 1032:}
        -: 1033:
        2: 1034:size_t ATHandler::write_bytes(uint8_t *data, size_t len)
        -: 1035:{
        2: 1036:    if (_last_err != NSAPI_ERROR_OK) {
        1: 1037:        return 0;
        -: 1038:    }
        -: 1039:
        1: 1040:    size_t i = 0;
        1: 1041:    for (; i < len; i++) {
        1: 1042:        if (write_char(data[i]) == false) {
        -: 1043:            // writing failed ---> write_char have set the last error, return
        1: 1044:            break;
        -: 1045:        }
        -: 1046:    }
        -: 1047:
        1: 1048:    return i;
        -: 1049:}
        -: 1050:
       22: 1051:bool ATHandler::write_char(char c)
        -: 1052:{
        -: 1053:    pollfh fhs;
       22: 1054:    fhs.fh = _fileHandle;
       22: 1055:    fhs.events = POLLOUT;
       22: 1056:    bool retVal = true;
        -: 1057:
       22: 1058:    int count = poll(&fhs, 1, _at_timeout);
       22: 1059:    if (count > 0 && (fhs.revents & POLLOUT)) {
       18: 1060:        retVal = _fileHandle->write(&c, 1) == 1 ? true : false;
        -: 1061:    } else {
        4: 1062:        retVal = false;
        -: 1063:    }
        -: 1064:
       22: 1065:    if (retVal == false) {
        9: 1066:        set_error(NSAPI_ERROR_DEVICE_ERROR);
        -: 1067:    }
        -: 1068:
       22: 1069:    return retVal;
        -: 1070:}
        -: 1071:
        -: 1072:// do common checks before sending subparameters
        9: 1073:bool ATHandler::check_cmd_send()
        -: 1074:{
        9: 1075:    if (_last_err != NSAPI_ERROR_OK) {
        3: 1076:        return false;
        -: 1077:    }
        -: 1078:
        -: 1079:    // Don't write delimiter if this is the first subparameter
        6: 1080:    if (_cmd_start) {
        1: 1081:        _cmd_start = false;
        -: 1082:    } else {
        5: 1083:        if (write_char(_delimiter) == false) {
        -: 1084:            // writing of delimiter failed, return. write_char already have set the _last_err
        2: 1085:            return false;
        -: 1086:        }
        -: 1087:    }
        -: 1088:
        4: 1089:    return true;
        -: 1090:}
        -: 1091:
       33: 1092:void ATHandler::flush()
        -: 1093:{
       34: 1094:    while (_fileHandle->readable()) {
        1: 1095:        reset_buffer();
        1: 1096:        fill_buffer();
        -: 1097:    }
       32: 1098:    reset_buffer();
       32: 1099:}
