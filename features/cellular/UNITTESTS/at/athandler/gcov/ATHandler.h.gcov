        -:    0:Source:../../../framework/AT/ATHandler.h
        -:    0:Graph:objs/ATHandler_unit/ATHandler.gcno
        -:    0:Data:objs/ATHandler_unit/ATHandler.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/*
        -:    2: * Copyright (c) 2017, Arm Limited and affiliates.
        -:    3: * SPDX-License-Identifier: Apache-2.0
        -:    4: *
        -:    5: * Licensed under the Apache License, Version 2.0 (the "License");
        -:    6: * you may not use this file except in compliance with the License.
        -:    7: * You may obtain a copy of the License at
        -:    8: *
        -:    9: *     http://www.apache.org/licenses/LICENSE-2.0
        -:   10: *
        -:   11: * Unless required by applicable law or agreed to in writing, software
        -:   12: * distributed under the License is distributed on an "AS IS" BASIS,
        -:   13: * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   14: * See the License for the specific language governing permissions and
        -:   15: * limitations under the License.
        -:   16: */
        -:   17:
        -:   18:#ifndef AT_HANDLER_H_
        -:   19:#define AT_HANDLER_H_
        -:   20:
        -:   21:#include "platform/mbed_retarget.h"
        -:   22:#include "stdio.h"
        -:   23:
        -:   24:#include "EventQueue.h"
        -:   25:#include "PlatformMutex.h"
        -:   26:#include "nsapi_types.h"
        -:   27:
        -:   28:#include "PlatformMutex.h"
        -:   29:#include "Callback.h"
        -:   30:#include "EventQueue.h"
        -:   31:
        -:   32:namespace mbed {
        -:   33:
        -:   34:class FileHandle;
        -:   35:
        -:   36:/**
        -:   37: * If application calls associated FileHandle only from single thread context
        -:   38:  * then locking between AT command and response is not needed. However,
        -:   39:  * note that many cellular functions are called indirectly e.g. via socket API.
        -:   40:  * If you are unsure then AT_HANDLER_MUTEX must be defined.
        -:   41:  */
        -:   42:#define AT_HANDLER_MUTEX
        -:   43:
        -:   44:extern const char *OK;
        -:   45:extern const char *CRLF;
        -:   46:
        -:   47:#define BUFF_SIZE 16
        -:   48:
        -:   49:/* AT Error types enumeration */
        -:   50:enum DeviceErrorType {
        -:   51:    DeviceErrorTypeNoError = 0,
        -:   52:    DeviceErrorTypeError,       // AT ERROR
        -:   53:    DeviceErrorTypeErrorCMS,    // AT ERROR CMS
        -:   54:    DeviceErrorTypeErrorCME     // AT ERROR CME
        -:   55:};
        -:   56:
        -:   57:/* struct used when getting at response error. Defines error code and type */
        -:   58:struct device_err_t {
        -:   59:    DeviceErrorType errType;
        -:   60:    int errCode;
        -:   61:};
        -:   62:
        -:   63:/** Class ATHandler
        -:   64: *
        -:   65: *  Class for sending AT commands and parsing AT responses.
        -:   66: */
        -:   67:class ATHandler
        -:   68:{
        -:   69:
        -:   70:public:
        -:   71:    /** Constructor
        -:   72:     *
        -:   73:     *  @param fh               file handle used for reading AT responses and writing AT commands
        -:   74:     *  @param queue            Event queue used to transfer sigio events to this thread
        -:   75:     *  @param timeout          Timeout when reading for AT response
        -:   76:     *  @param output_delimiter Default delimiter used when parsing at responses
        -:   77:     */
        -:   78:    ATHandler(FileHandle *fh, events::EventQueue &queue, int timeout, const char *output_delimiter = "\r");
        -:   79:    ~ATHandler();
        -:   80:
        -:   81:    /** Return used file handle.
        -:   82:     *
        -:   83:     *  @return used file handle
        -:   84:     */
        -:   85:    FileHandle *get_file_handle();
        -:   86:
        -:   87:    /** Set file handle which is used for reading AT responses and writing AT commands
        -:   88:     *
        -:   89:     *  @param fh file handle used for reading AT responses and writing AT commands
        -:   90:     */
        -:   91:    void set_file_handle(FileHandle *fh);
        -:   92:
        -:   93:    /** Locks the mutex for file handle if AT_HANDLER_MUTEX is defined.
        -:   94:     */
        -:   95:    void lock();
        -:   96:
        -:   97:    /** Unlocks the mutex for file handle if AT_HANDLER_MUTEX is defined.
        -:   98:     */
        -:   99:    void unlock();
        -:  100:
        -:  101:    /** Locks the mutex for file handle if AT_HANDLER_MUTEX is defined and returns the last error.
        -:  102:     *
        -:  103:     * @return last error which happened when parsing AT responses
        -:  104:     */
        -:  105:    nsapi_error_t unlock_return_error();
        -:  106:
        -:  107:    /** Set the urc callback for urc. If urc is found when parsing AT responses then call if called.
        -:  108:     *
        -:  109:     *  @param prefix   Register urc prefix for callback. Urc could be for example "+CMTI: "
        -:  110:     *  @param callback Callback which is called if urc is found in AT response
        -:  111:     */
        -:  112:    void set_urc_handler(const char *prefix, mbed::Callback<void()> callback);
        -:  113:
        -:  114:    ATHandler *_nextATHandler; // linked list
        -:  115:
        -:  116:    /** returns the last error while parsing AT responses.
        -:  117:     *
        -:  118:     *  @return last error
        -:  119:     */
        -:  120:    nsapi_error_t get_last_error() const;
        -:  121:
        -:  122:    /** returns the last device error while parsing AT responses. Actually AT error (CME/CMS).
        -:  123:     *
        -:  124:     *  @return last error struct device_err_t
        -:  125:     */
        -:  126:    device_err_t get_last_device_error() const;
        -:  127:
        -:  128:    /** Increase reference count. Used for counting references to this instance.
        -:  129:     */
        -:  130:    void inc_ref_count();
        -:  131:
        -:  132:    /** Decrease reference count. Used for counting references to this instance.
        -:  133:     */
        -:  134:    void dec_ref_count();
        -:  135:
        -:  136:    /** Get the current reference count. Used for counting references to this instance.
        -:  137:     *
        -:  138:     *  @return current reference count
        -:  139:     */
        -:  140:    int get_ref_count();
        -:  141:
        -:  142:    /** Set timeout in milliseconds for AT commands
        -:  143:     *
        -:  144:     *  @param timeout_milliseconds  Timeout in milliseconds
        -:  145:     *  @param default_timeout       Store as default timeout
        -:  146:     */
        -:  147:    void set_at_timeout(uint32_t timeout_milliseconds, bool default_timeout = false);
        -:  148:
        -:  149:    /** Restore timeout to previous timeout. Handy if there is a need to change timeout temporarily.
        -:  150:     */
        -:  151:    void restore_at_timeout();
        -:  152:
        -:  153:    /** Clear pending error flag. By default error is cleared only in lock().
        -:  154:     */
        -:  155:    void clear_error();
        -:  156:
        -:  157:    /** Tries to find oob's from the AT response. Call the urc callback if one is found.
        -:  158:     */
        -:  159:    void process_oob();
        -:  160:
        -:  161:    /** Set sigio for the current file handle. Sigio event goes through eventqueue so that it's handled in current thread.
        -:  162:     */
        -:  163:    void set_filehandle_sigio();
        -:  164:
        -:  165:    /**
        -:  166:     * Flushes the underlying stream
        -:  167:     */
        -:  168:    void flush();
        -:  169:
        -:  170:protected:
        -:  171:    void event();
        -:  172:#ifdef AT_HANDLER_MUTEX
        -:  173:    PlatformMutex _fileHandleMutex;
        -:  174:#endif
        -:  175:    FileHandle *_fileHandle;
        -:  176:private:
        -:  177:
        -:  178:    void set_error(nsapi_error_t err);
        -:  179:    void set_oobs_matching_param(bool);
        -:  180:
        -:  181:    events::EventQueue &_queue;
        -:  182:    nsapi_error_t _last_err;
        -:  183:    nsapi_error_t _last_3gpp_error;
        -:  184:    device_err_t  _last_at_err;
        -:  185:    uint16_t _oob_string_max_length;
        -:  186:    char *_output_delimiter;
        -:  187:    uint8_t _output_delimiter_length;
        -:  188:
        6:  189:    struct oob_t {
        -:  190:        bool matching_to_received;
        -:  191:        const char *prefix;
        -:  192:        mbed::Callback<void()> cb;
        -:  193:        oob_t *next;
        -:  194:    };
        -:  195:    oob_t *_oobs;
        -:  196:    bool _response_terminated;
        -:  197:    uint32_t _at_timeout;
        -:  198:    uint32_t _previous_at_timeout;
        -:  199:
        -:  200:    bool _fh_sigio_set;
        -:  201:
        -:  202:    bool _processing;
        -:  203:    int32_t _ref_count;
        -:  204:
        -:  205:        //*************************************
        -:  206:public:
        -:  207:
        -:  208:    /** Starts the command writing by clearing the last error and writing the given command.
        -:  209:     *  In case of failure when writing the last error is set to NSAPI_ERROR_DEVICE_ERROR.
        -:  210:     *
        -:  211:     *  @param cmd  AT command to be written to modem
        -:  212:     */
        -:  213:    void cmd_start(const char* cmd);
        -:  214:
        -:  215:    /** Writes integer type AT command subparameter. Starts with the delimiter if not the first param after cmd_start.
        -:  216:     *  In case of failure when writing the last error is set to NSAPI_ERROR_DEVICE_ERROR.
        -:  217:     *
        -:  218:     *   @param param int to be written to modem as AT command subparameter
        -:  219:     */
        -:  220:    void write_int(int32_t param);
        -:  221:
        -:  222:    /** Writes string type AT command subparamater. Quotes are added to surround the given string.
        -:  223:     *  Starts with the delimiter if not the first param after cmd_start.
        -:  224:     *  In case of failure when writing the last error is set to NSAPI_ERROR_DEVICE_ERROR.
        -:  225:     *
        -:  226:     *  @param param string to be written to modem as AT command subparameter
        -:  227:     *  @param useQuotations flag indicating if the string should be or not included in quotation marks
        -:  228:     */
        -:  229:    void write_string(const char* param,  bool useQuotations = true);
        -:  230:
        -:  231:    /** Stops the AT command by writing command line terminator CR to mark command as finished.
        -:  232:     */
        -:  233:    void cmd_stop();
        -:  234:
        -:  235:    /** Write bytes without any subparameter delimiters, such as comma.
        -:  236:     *  In case of failure when writing the last error is set to NSAPI_ERROR_DEVICE_ERROR.
        -:  237:     *
        -:  238:     *  @param data bytes to be written to modem
        -:  239:     *  @param len  length of data string
        -:  240:     *
        -:  241:     *  @return     number of characters successfully written
        -:  242:     */
        -:  243:    size_t write_bytes(uint8_t *data, size_t len);
        -:  244:
        -:  245:    /** Sets the stop tag for the current scope(response/information response/element)
        -:  246:     *  Parameter's reading routines will stop the reading when such tag is found and will set the found flag.
        -:  247:     *  Consume routines will read everything until such tag is found.
        -:  248:     *
        -:  249:     *  @param stop_tag_seq string to be set as stop tag
        -:  250:     */
        -:  251:    void set_stop_tag(const char *stop_tag_seq);
        -:  252:
        -:  253:    /** Sets the delimiter between parameters or between elements of the information response.
        -:  254:     *  Parameter's reading routines will stop when such char is read.
        -:  255:     *
        -:  256:     *  @param delimiter char to be set as _delimiter
        -:  257:     */
        -:  258:    void set_delimiter(char delimiter);
        -:  259:
        -:  260:    /** Consumes the reading buffer up to the delimiter or stop_tag
        -:  261:     *
        -:  262:     *  @param count number of parameters to be skipped
        -:  263:     */
        -:  264:    void skip_param(uint32_t count = 1);
        -:  265:
        -:  266:    /** Consumes the given length from the reading buffer
        -:  267:     *
        -:  268:     *  @param len length to be consumed from reading buffer
        -:  269:     *  @param count number of parameters to be skipped
        -:  270:     */
        -:  271:    void skip_param(ssize_t len, uint32_t count);
        -:  272:
        -:  273:    /** Reads given number of bytes from receiving buffer without checking any subparameter delimiters, such as comma.
        -:  274:     *
        -:  275:     *  @param buf output buffer for the read
        -:  276:     *  @param len maximum number of bytes to read
        -:  277:     *  @return number of successfully read bytes or -1 in case of error
        -:  278:     */
        -:  279:    ssize_t read_bytes(uint8_t *buf, size_t len);
        -:  280:
        -:  281:    /** Reads chars from reading buffer. Terminates with null. Skips the quotation marks.
        -:  282:     *  Stops on delimiter or stop tag.
        -:  283:     *
        -:  284:     *  @param str output buffer for the read
        -:  285:     *  @param size maximum number of chars to output
        -:  286:     *  @param read_even_stop_tag if true then try to read even the stop tag was found previously
        -:  287:     *  @return length of output string or -1 in case of read timeout before delimiter or stop tag is found
        -:  288:     */
        -:  289:    ssize_t read_string(char *str, size_t size, bool read_even_stop_tag = false);
        -:  290:
        -:  291:    /** Reads as string and converts result to integer. Supports only positive integers.
        -:  292:     *
        -:  293:     *  @return the positive integer or -1 in case of error.
        -:  294:     */
        -:  295:    int32_t read_int();
        -:  296:
        -:  297:    /**  This looks for necessary matches: prefix, OK, ERROR, URCs and sets the correct scope.
        -:  298:     *
        -:  299:     *  @param prefix string to be matched from receiving buffer. If not NULL and match succeeds, then scope
        -:  300:     *          will be set as information response(info_type)
        -:  301:     *  @param stop flag to indicate if we go to information response scope or not.
        -:  302:     *        (needed when nothing is expected to be received anymore after the prefix match:
        -:  303:     *         sms case: "> ", bc95 reboot case)
        -:  304:     */
        -:  305:    void resp_start(const char *prefix = NULL, bool stop = false);
        -:  306:
        -:  307:    /**  Ends all scopes starting from current scope.
        -:  308:     *   Consumes everything until the scope's stop tag is found, then
        -:  309:     *   goes to next scope, until response scope is ending.
        -:  310:     *   Possible sequence:
        -:  311:     *   element scope -> information response scope -> response scope
        -:  312:     */
        -:  313:    void resp_stop();
        -:  314:
        -:  315:    /**  Looks for matching the prefix given to resp_start() call.
        -:  316:     *   If needed it ends the scope of a previous information response.
        -:  317:     *   Sets the information response scope if new prefix is found and response scope if prefix is not found.
        -:  318:     *
        -:  319:     *  @return true if new information response is found, false otherwise
        -:  320:     */
        -:  321:    bool info_resp();
        -:  322:
        -:  323:    /**  Looks for matching the start tag.
        -:  324:     *   If needed it ends the scope of a previous element.
        -:  325:     *   Sets the element scope if start tag is found and information response scope if start tag is not found.
        -:  326:     *
        -:  327:     *  @param start_tag tag to be matched to begin parsing an element of an information response
        -:  328:     *  @return true if new element is found, false otherwise
        -:  329:     */
        -:  330:    bool info_elem(char start_tag);
        -:  331:
        -:  332:    /**  Consumes the received content until current stop tag is found.
        -:  333:     *
        -:  334:     *  @return true if stop tag is found, false otherwise
        -:  335:     */
        -:  336:    bool consume_to_stop_tag();
        -:  337:
        -:  338:    /**  Sets _debug_on flag.
        -:  339:     *
        -:  340:     *  @param enable value to be set for _debug_on flag
        -:  341:     */
        -:  342:    void enable_debug(bool enable);
        -:  343:
        -:  344:    /** Return the last 3GPP error code.
        -:  345:     *  @return last 3GPP error code
        -:  346:     */
        -:  347:    uint8_t get_3gpp_error();
        -:  348:
        -:  349:private:
        -:  350:
        -:  351:    // should fit any prefix and int
        -:  352:    char _recv_buff[BUFF_SIZE];
        -:  353:    // reading position
        -:  354:    size_t _recv_len;
        -:  355:    // reading length
        -:  356:    size_t _recv_pos;
        -:  357:
        -:  358:    // resp_type: the part of the response that doesn't include the information response(+CMD1,+CMD2..)
        -:  359:    //            ends with OK or (CME)(CMS)ERROR
        -:  360:    // info_type: the information response part of the response: starts with +CMD1 and ends with CRLF
        -:  361:    //            information response contains parameters or subsets of parameters(elements), both separated by comma
        -:  362:    // elem_type: subsets of parameters that are part of information response, its parameters are separated by comma
        -:  363:    enum ScopeType {RespType, InfoType, ElemType, NotSet};
        -:  364:    void set_scope(ScopeType scope_type, const char* stop_tag = NULL);
        -:  365:    ScopeType _current_scope;
        -:  366:
        -:  367:    struct tag_t {
        -:  368:        char tag[7];
        -:  369:        size_t len;
        -:  370:        bool found;
        -:  371:    };
        -:  372:
        -:  373:    // tag to stop response scope
        -:  374:    tag_t _resp_stop;
        -:  375:    // tag to stop information response scope
        -:  376:    tag_t _info_stop;
        -:  377:    // tag to stop element scope
        -:  378:    tag_t _elem_stop;
        -:  379:    // reference to the stop tag of current scope(resp/info/elem)
        -:  380:    tag_t *_stop_tag;
        -:  381:
        -:  382:    // delimiter between parameters and also used for delimiting elements of information response
        -:  383:    char _delimiter;
        -:  384:    // set true on prefix match -> indicates start of an information response or of an element
        -:  385:    bool _prefix_matched;
        -:  386:    // set true on urc match
        -:  387:    bool _urc_matched;
        -:  388:    // set true on (CME)(CMS)ERROR
        -:  389:    bool _error_found;
        -:  390:    // Max length of OK,(CME)(CMS)ERROR and URCs
        -:  391:    size_t _max_resp_length;
        -:  392:
        -:  393:    // prefix set during resp_start and used to try matching possible information responses
        -:  394:    char _info_resp_prefix[BUFF_SIZE];
        -:  395:    bool _debug_on;
        -:  396:    bool _cmd_start;
        -:  397:
        -:  398:    // Gets char from receiving buffer.
        -:  399:    // Resets and fills the buffer if all are already read (receiving position equals receiving length).
        -:  400:    int16_t get_char();
        -:  401:    // Sets to 0 the reading position, reading length and the whole buffer content.
        -:  402:    void reset_buffer();
        -:  403:    // Reading position set to 0 and buffer's unread content moved to beginning
        -:  404:    void rewind_buffer();
        -:  405:    // Reads from serial to receiving buffer.
        -:  406:    // Returns on first successful read OR on timeout.
        -:  407:    void fill_buffer();
        -:  408:
        -:  409:    void set_tag(tag_t* tag_dest, const char *tag_seq);
        -:  410:
        -:  411:    // Rewinds the receiving buffer and compares it against given str.
        -:  412:    bool match(const char* str, size_t size);
        -:  413:    // Iterates URCs and check if they match the receiving buffer content.
        -:  414:    // If URC match sets the scope to information response and after urc's cb returns
        -:  415:    // finishes the information response scope(consumes to CRLF).
        -:  416:    bool match_urc();
        -:  417:    // Checks if any of the error strings are matching the receiving buffer content.
        -:  418:    bool match_error();
        -:  419:    // Checks is current char in buffer matches ch and consumes it,
        -:  420:    // if no match lets the buffer unchanged.
        -:  421:    bool consume_char(char ch);
        -:  422:    // Consumes the received content until tag is found.
        -:  423:    // Consumes the tag only if consume_tag flag is true.
        -:  424:    bool consume_to_tag(const char *tag, bool consume_tag);
        -:  425:    // Checks if receiving buffer contains OK, ERROR, URC or given prefix.
        -:  426:    void resp(const char *prefix, bool check_urc);
        -:  427:
        -:  428:
        -:  429:    ScopeType get_scope();
        -:  430:
        -:  431:    // Consumes to information response stop tag which is CRLF. Sets scope to response.
        -:  432:    void information_response_stop();
        -:  433:    // Consumes to element stop tag. Sets scope to information response
        -:  434:    void information_response_element_stop();
        -:  435:
        -:  436:    // Reads the error code if expected and sets it as last error.
        -:  437:    void at_error(bool error_code, DeviceErrorType error_type);
        -:  438:
        -:  439:    /** Convert AT error code to 3GPP error codes
        -:  440:     *  @param err AT error code read from CME/CMS ERROR responses
        -:  441:     *  @param error_type error type (CMS/CME/ERROR)
        -:  442:     */
        -:  443:    void set_3gpp_error(uint8_t err, DeviceErrorType error_type);
        -:  444:
        -:  445:    bool check_cmd_send();
        -:  446:    bool write_char(char c);
        -:  447:
        -:  448:    /** Copy content of one char buffer to another buffer and sets NULL terminator
        -:  449:     *
        -:  450:     *  @param dest                  destination char buffer
        -:  451:     *  @param src                   source char buffer
        -:  452:     *  @param src_len               number of bytes to copy
        -:  453:     *
        -:  454:     */
        -:  455:    void set_string(char *dest, const char *src, size_t src_len);
        -:  456:
        -:  457:    /** Finds occurence of one char buffer inside another char buffer.
        -:  458:     *
        -:  459:     * @param dest                  destination char buffer
        -:  460:     * @param dest_len              length of dest
        -:  461:     * @param src                   string to be searched for
        -:  462:     * @param src_len               length of string to be searched for
        -:  463:     *
        -:  464:     * @return pointer to first occurrence of src in dest
        -:  465:     */
        -:  466:    const char* mem_str(const char* dest, size_t dest_len, const char* src, size_t src_len);
        -:  467:};
        -:  468:
        -:  469:} // namespace mbed
        -:  470:
        -:  471:#endif //AT_HANDLER_H_
